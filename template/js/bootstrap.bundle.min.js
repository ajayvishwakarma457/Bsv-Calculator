/*!
  * Bootstrap v5.2.3 (https://getbootstrap.com/)
  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function  (t ,  e ) { "obj ec t" == typeof e xp orts && "un de fined" != typ e of module ? mo d ule . exports =  e( ) : "function "  == typeof  d efine &&  d ef i ne.amd ? de fi ne(e) : (t = "und e fined" !=  t y pe of globalThis ?   glo balThis  : t || s el f ).bootstrap =  e() }( t his, (function ( )   {  " u se st r ict"; const t = "transitionend",  e  = t  = > {  le t  e  = t. g etAttribute("data-bs-ta rg et" );  if (!e || "#" = ==  e) { let i = t.get Attribute("h ref"); if (!i | |  !i.includes("#") & &  !i . startsWith(".")) return   n u ll ; i .in c l udes("#" )  &&  ! i.starts Wi t h ( "# " ) && (i   = `#$ {i.split (" #")[1]}`), e = i && "#" ! = =   i ?  i. t r i m( )  : null   } ret urn e },   i = t => { const i = e(t) ;  ret ur n   i  & &  document.querySelector(i) ?  i  :   n ul l },  n  = t =>  {  const i =  e (t); re tur n i ? do cu me n t.quer ySelec tor (i) : null } ,   s  =  e = >  { e.dis p atch E v e nt(new E ve nt(t)) } ,  o = t =>   ! ( !t || "object" != typeof  t ) &&  ( v o id   0  !== t. jq u ery  && (t = t[0]), void 0 !==  t.nod eTy pe), r  =  t => o(t ) ?  t.jquery ? t[0] : t : "string" == typeof t && t.le n g th > 0 ? document.querySelector(t )  : nu ll, a = t  = >  { i f  ( !o(t) | |  0 === t.getClientRec ts () .l ength) retur n ! 1;  const  e  =  "visi ble "  === ge tC o mputedSt yl e ( t ). ge tP ropertyVal ue( "visibility"), i  =  t.closest("details:not([open])");  if  (!i) r etu rn e; if ( i  !== t) {  c onst e = t.closest("summar y" ); if ( e & & e.parentNode !== i) return   ! 1 ;  i f  (null === e) return !1 } return e }, l =  t => !t ||  t. nodeType != =  Node.ELEMENT_NODE ||  ! !t.clas s List.contains("d isabled") || (void 0 !== t.dis a b l ed ?   t.disabled : t.hasAttribute("d i s a bled") && "f a lse" !== t.getA t trib ut e ( "d is a bl e d " )) ,  c = t => { if  ( ! d oc um ent.documentE le ment.attachShadow) return null; if ("function" = =  typeof t.get R ootNo d e ) {   c on st  e =  t.g etRootNode(); return e instan c e o f  S hadowR o o t  ?  e  : null   } re tu rn  t  instan c eof Sha d o wRoot ?  t : t.p a rentNode ? c(t.par entNode) : null },  h  =  () => { }, d = t  = >  {  t.offset H ei ght }, u = () => w i nd ow.jQuery  &&  !document.body.has A ttribute( "d ata-bs-no-jquery") ? window.jQuery : null, f  = [ ],   p =  () => "rtl" = ==  docu ment.docum e ntE le m e n t. d ir, g = t  =>  { var e ;  e =  ( )   =>  {  c o nst  e   =  u();  if (e) { const i  = t.NA M E,  n   =  e.fn [i]; e.fn [i]   = t.jQueryInterface ,  e.fn[i].Construc t o r  = t, e.fn[i].noConflict =  () => ( e .fn[i] = n, t.jQueryI n t erface) } }, "loading " === do cu m e nt . readyState ? (f. l e ngth || document .ad d EventListener("DOMCon t entLoaded", (() => { f o r  (con s t  t of  f ) t () })),   f. push(e) )  :  e ( )  },   m  =  t  =>  { "function" == typeof  t & & t()  } , _ = (e, i, n = !0)  =>  { if (!n) retu rn   v oi d m( e);  c on s t  o  =  (t  = >  {  if (!t )  return 0 ; let   { transitionD uratio n:  e,   t ra ns i t ion D el a y: i   }  =  w i n d ow. g et Co m pu t ed S tyl e(t); const n  = Number.p a r seFlo at ( e ), s = Number.parseFl o a t(i); r e t urn n ||  s   ? ( e = e . sp lit("," ) [ 0], i = i.s plit(",")[0] , 1e3 * (Nu mber.parse Fl o a t(e) + Number.par seFloat(i)) ) : 0 })(i ) + 5; let r  = !1; const a  = ({ target:  n }) => { n ===  i && (r = !0 , i.removeE ventListener (t, a), m(e))  }; i.addEven tListener( t, a), setT imeout(( () => { r || s(i) }) , o) }, b = ( t, e, i, n)  => { const  s = t.length;  let o = t.inde xOf(e); return  -1 === o ?  !i && n ? t[s -  1] : t[0] : (o  += i ? 1 : -1,  n && (o = (o + s ) % s), t[Mat h.max(0,  Math.m in(o, s -  1))]) } , v = /[^ .]*(?=\.. *)\.|.*/,  y = /\..*/,  w = /: :\d+$/, A  = {}; let E =  1; const  T = { m ouseenter: "mouseov er", mouseleave: "m ouseout"  }, C =  new Set(["c lick", "dblcl ic k ", "mous eu p", "mousedown ",  "contextm en u",   "mousewheel",   "DOMMou s eScro ll", "mouseover",   "m ouse o ut",  " mou semo v e", "selectst ar t " , "se l ectend", "keydown", "keypress",  " keyup", "o rie n ta tionchange", "touchs tar t",   "touchmove",  "t ou c hend",  " touchcan ce l", "poin t e r d o w n ",  " point e rmove ", "pointerup",  " po i nte rle av e" ,  "pointercanc el ",  " ge s tu restart",  " gesturec ha nge ", "ges tur een d" ,  " focu s" , " bl ur", "ch a nge", " r e se t", "sel ect " ,  "submit", "focusi n" , "focusout", " loa d", "unload", "b ef oreunload", "resize", "move", "DOMContentLoa ded", "readystatech an ge " ,  "er r or", "a b ort",   " scro ll "]);  f unct i o n O( t,   e )   { retu rn  e  && `${e}::$ {E++}` ||   t.uidEve nt  ||  E++ }  f unct ion x(t) { c onst  e   =   O(t); re tur n  t. u idEvent = e, A[e] =  A [e] ||  { }, A[e] } function k(t , e , i  =  null)  {   r et u rn   Obj ect.v a l ues(t).find((t = > t.callable = ==  e  &&  t .delegation S elector === i))   } f unction  L( t, e, i)  { cons t  n =  "string"  == t y peof  e ,  s  = n ? i  :  e  | | i; let o = N(t); r e turn C.has( o ) || (o = t), [ n , s , o] } f un ction D( t, e, i , n , s) { if  ("st r ing"  !=  typeof e || !t) ret u r n ;   let [ o, r, a] =   L( e, i, n) ;  i f (e in T)   {  cons t  t  = t => function (e)  {  if   (!e.relatedTa rg et  | |  e .relate d Target  != = e . de legateTarget && !e.delega te Target.conta ins(e.relatedTarget)) re t urn t.call(th is ,  e)   }; r =  t (r)  }  con st  l = x(t), c = l[a] || (l[a]  =  {}), h = k(c,  r , o ? i   : nul l);  if  ( h) return v oid (h.oneOff = h.one O f f && s); cons t  d = O(r ,  e.replace(v , "" )),  u  =   o ? fun c t ion ( t,  e ,  i ) {  re tu rn  fu nc tion n (s )  {  c onst  o  =  t .qu er ySelec to rA ll ( e) ; for (le t  { target :  r }  = s; r  && r  != =  th i s; r  =  r. p a r ent No d e )for  ( c onst  a  of   o ) if (a === r) ret ur n j(s,  { d el e ga teT arg et: r }), n.oneOff && P.off (t,  s. ty pe, e, i), i .ap ply(r, [s]) } }(t, i, r) :  f unction   (t, e) { ret urn  fu nct io n i(n) { retur n  j(n, {   deleg ateT ar ge t: t }), i. oneOff && P.off(t, n. t y p e, e ) ,  e.apply(t, [n]) } }(t, r ); u.de lega ti on Se l e c t or =  o  ?  i : null,  u .c a ll able = r,  u .oneOff  =  s,  u.uidEvent =  d, c[d ]  = u , t.a d dEven t L ist e n er( a ,  u,   o)  } fu nc t io n  S (t, e, i,  n,  s) { const o = k ( e [i], n, s); o && (t.remove E v entListener(i, o, Boolean(s)), dele t e  e[i][o.uidEvent]) } fun ction   I(t, e, i, n )  { const  s  = e[i] ||  {} ; f or (cons t  o o f O b je ct.keys(s)) if (o.i n cl udes(n)) { const n  = s[o]; S(t, e, i,  n . ca llable, n.delegatio n S el ector) } } fu nc t ion  N(t)  { r et urn t = t.replace(y ,  ""),  T[ t ] ||   t   } con st  P  = { on(t, e, i, n) { D( t,   e, i, n, !1)  },  one( t,  e ,  i ,  n) { D( t , e, i,   n, !0) } ,   o ff(t,  e,  i ,  n) { if  ( "string"  != typeo f e ||  ! t) return ; const  [s ,  o,  r] =  L (e, i, n ),   a = r !== e, l = x(t), c = l[r] || {}, h = e.startsWith("."); if (void 0 === o) { if (h) for (const i of Object.keys(l))  I (t,  l,  i,  e .slice(1 )) ; for (const i  of  Obje ct.keys(c ))   {  const n = i .replac e(w, "" ) ; if (!a  || e.include s (n) ) { co ns t e = c[i];   S( t, l, r, e.ca l la ble, e. del eg ationS ele ct or) } }  } e ls e { if  (! Ob je ct. keys(c).length) retur n; S(t, l, r, o,  s  ? i  :  n ul l) } } , t ri gger(t, e, i )  { if ("st ri ng" != ty peof e ||  !t )  return null; const n = u(); let s = nul l , o =  !0 ,  r = !0,   a  = !1; e !==  N (e) && n && (s = n.Event(e ,  i) , n(t).trigger(s), o =  ! s.isPro p a gationStopped(), r  =  !s . isImmediatePropagationStopped(),  a  =  s.isDefaultPrevented() );   let l = new Event(e, { bubbles: o, c an celable: !0 }); retu r n  l =  j(l, i ),  a && l. p rev e n tDefault(), r && t.dispatchEvent (l ), l.defaultPreven te d && s && s.preventDefault() , l  } }; function   j(t,  e ) { for (const [ i, n ]   of Object.entries(e || {} ) ) try { t[ i] = n } c atch   (e) { Object.de f inePrope rt y(t, i, { configu rab le :  !0, get: () => n }) } return t } con st  M = ne w  Map, H = { set(t, e ,  i) {  M. h as(t) || M.set(t, new Ma p ); con st   n = M.get(t); n.h a s(e) || 0 === n.size ? n.set(e, i) : console.error(`Bootstrap doesn't allow more than  o ne instance p e r elemen t . Bound instance: ${Arra y . from(n.keys())[0]}.`) }, g et: (t, e) => M.has(t) &&   M .get(t).get(e) || nu l l, remov e (t, e) { if (!M.ha s( t )) retu r n; c o nst i = M.get(t); i.d elete(e),   0 = == i.s i ze && M.delete(t) } }; funct ion $(t) {  if  ("true"   = = = t ) retur n  !0; if ("false" === t )  re turn !1; if  ( t === Nu m b e r( t ) .toString()) return   N umber(t); if ("" === t || "nu l l"  === t) return null; if ("st r ing" !=   typeo f   t) re t u rn t ;  try { re t urn  JS ON . pa r se(dec o deURIComponent(t)) } catch (e) { return t } } function W(t) { return t.r ep lace(/[A-Z]/g, (t => `-$ {t.toLowerCase()}`)) } const B = { setDataAttribute(t, e, i) { t.setAttribute(`data-bs-${W(e)}`, i) }, removeDataAttribute( t , e)  {   t.removeAttribute ( `data-bs-${W(e )} ` ) }, get Da t aAttr ib utes(t) { if ( ! t)  return {};  c onst e = {}, i = Ob ject.keys(t.dataset) .filter((t => t.startsWith ("bs")   && !t.sta r tsWith("bsConfig"))); f or (const n of i) { let i =  n.replace(/^bs/, "" ); i = i.charAt(0).toLowerCa se( ) + i.slice(1, i.length), e[i] = $(t.dataset[ n]) } r e turn   e }, getDataAttri bu t e : ( t , e)  = >  $ (t.getAttribu t e(`data- b s-${W(e)}`)) }; class F  { static get D e f ault() { return {} } stati c get DefaultType() { ret u r n {} } static get NAM E () { throw new Err or('You have t o  implement the static method  " N AME " , for each component!') }  _g etConfig(t)  { retur n  t = this . _ m ergeC o nfigObj(t), t = this . _confi gAfterM e rge(t), this._typeChe c kConfi g(t), t } _config A fterMerge(t) { return  t  } _me rgeConfigObj(t, e)  {  const i = o(e) ? B . getDat aAttribute(e, "config")   :  {}; re t urn   {  ...thi s. c onstruc t or.Default, ..."object" == typ e o f i ? i  : {}, ...o(e)  ?  B.getDataAttributes(e) : { }, ..."ob jec t "  == typ eof t ? t : {} } } _typeCheckC on fig(t, e = this.con structor .Defaul tType)  {  for (c on st n of Object.keys(e) ) { const s = e[n], r = t[n],  a  =  o(r) ? "element"  :  null == (i = r)  ?  `${i} ` : Obj e ct.prot o ty pe.toString.call(i).match (/\s([a-z]+)/i)[1].toLowerCase(); i f (!new  RegExp(s).test(a)) throw new TypeError (`${thi s .constructor.NAME.toUpperCase()}: Option  "${n}" provided type "$ {a }" but expected type "${ s}".`) } var i  }   } class z extends   F { constructor(t, e) {  super(), (t = r(t)) &&  (this._element = t,  this._config  =  this._getConfig(e), H.se t (this._element, this.const ru c tor.DAT A _KEY, this)) } dispose() { H .r emove(thi s. _element,   th is.cons tru ctor .D ATA_KEY), P.off(t hi s._element, t his .c onstructor.EVENT_KEY); for (const t of Object. getOwnProp e rty N a mes( this)) th is[t]  = null   } _queueCallback(t, e, i = ! 0) { _(t, e, i) }   _getConfig(t) { r e turn t  = this. _ mergeCon f igObj(t, this._element), t = this._configA fterMerge(t), this._typeCheckConfig(t), t   } static getInstance(t) {   return H.get(r(t), this.DA TA _ KEY) }  s tatic getOrCreateInstance(t,  e = {})  {  r et urn th is. g e tInstance(t) | | new this(t, "object" == t yp eo f  e  ? e : null) } stat ic get  V ERSION() { return "5 .2.3" } static get DATA_KEY() { r etur n `bs .${this . N AME}`  }  s t atic get EVENT_KEY() { re tu rn `.${this.DATA_KEY}` } static eventName(t) { return ` ${t} ${this.E VEN T _ KEY}` } } const q = (t, e  =  "hide") => { const i = `click.dismiss$ {t. EVENT_KEY }`,  s  =  t.NAME; P.on(document, i, `[data- bs -dismiss="${s}" ]`, (funct io n  (i) {  i f ( ["A",   "AREA"].includes(this.ta gNa me ) && i.preven t D efault(), l(this)) retur n; const  o  = n(th is )  || t h is.closest(`.${s}`); t.ge tOr Cr eat e In stance(o)[e]()  })) } ; cl a s s R extends z { static g e t NAME ()  {  return  " a lert"   } close() { if (P.tri gge r( thi s ._ element, "clos e.bs.a lert " ) .defaultPrevented) r e turn;  th is ._element.classList. r emove(" s how") ; const t  = this. _element.cl assList.c ontains("f ade"); this._ queueCallback((() => this._destroy El ement()), this._element, t) } _destroyEl ement() { this._ele ment.remove( ),  P.tr ig ger(th i s. _ e l ement, "clos ed.bs .alert"), thi s.dis pose() } stati c jQ ue r y I nterface(t)  { return this.each ((function ()  { const e = R.get OrCreateInstan ce(this); if ("st ri ng" == typeof t)  {  if (void 0 == =  e [t] || t .startsWith(" _ ")   ||  "constructor"  == = t) throw ne w  TypeError(`No meth od named "${ t }" `); e[t](this) } })) } } q ( R, "close"), g(R); const V =  '[data-bs-toggle="b u tton"]'; class K ext e nds z {  s tatic get NAME() { retur n  "button "  } toggle() { thi s ._elem ent.set A ttribute( " aria-pressed", this. _element.cla s sList.tog g le("active")) } static jQu e ryInterface(t) { return this.ea ch ((function ()   { const e  =  K.getOrCrea t eInstance(this); "to g gle" == =  t && e[t]() })) } } P.on(docum en t, "click.bs. b utton.dat a -api", V, (t = > { t.preventDefault (); const e = t.target.clos e st(V); K . getOrCreateI n stance(e) .t oggle() })), g(K ) ;   c o nst Q = { find: (t,  e  = document. d ocumentElement )  => []. c oncat(...Element.protot yp e. qu ery Selecto rAll.ca l l ( e, t)), findO ne: (t, e =  d oc u me nt. d o c umentElement) => Element.p r ototype.querySelector.call ( e, t), childr e n: (t, e) => [].concat(... t .children).filter((t  => t.matches(e))), par en ts (t, e) { const i  = []; let n = t.par entNode.closest(e); f or  ( ; n;)i.push(n),  n = n.parentNode.closest(e); return i }, pre v (t, e) { let i = t.p reviousElementSibling;  f or  (; i;) { if (i.m atches(e)) return [ i]; i = i.previousEle me nt Sibling } return  [] }, next(t, e) {  let i = t.nextEleme nt Si bling; for (; i ; ) { if (i.matches(e)) retu r n [i]; i = i.nextElementSibling }  r eturn  []  }, focusableC hi ldren(t ) {  const e = ["a " , "button", "input",   "texta rea", "select" , "details", "[tabindex]",  '[ contenteditable="true"]' ] . m a p((t =>   `${t}:n o t ([tabin d e x^="-"] )` ) ).join(" ," ) ; return this.find( e,   t).filter(( t  = > !l(t) & &  a ( t))) } },  X =  { endCallb a ck :  n u ll, leftC allb ack: null , r ightCa llback:  null  },  Y = {  end Callb ac k:  " ( f unction|n ull)", leftCallback : "(funct ion|null)" , righ tCallback: "(functi on|nu ll)" }; class U ext ends F  { constru ctor( t, e) { s up er(), this._elemen t  = t, t && U.i sS u pported( ) & & (this._confi g  = th is._getConfig(e), t h is._d eltaX = 0, this . _su pportPointerEvent s  = Bo olean(window.Poin t erEve nt), this._initEvents() )  } static get Default() { return  X } static get  DefaultType() { return Y }  static get NAME( ) {  r et urn "swipe"  }  dispose() { P.off(t h is._eleme n t, ".bs.swipe") } _start ( t) { this . _supportPointerEv e nts ?  this._even t IsPoin t erPenTouch(t)  & & (this._deltaX =   t.clientX) : thi s. _deltaX = t.touc he s[0].client X  } _en d (t) { this._ev e ntIsPoi n terPenTouch(t)  &&  (this._deltaX =  t.clientX - this._del t aX), th i s._handleSwipe(), m(th is._config.endCallback)  } _move(t) {  t his._deltaX = t .t ouches && t.touches.leng th > 1 ? 0 : t.touches [ 0].clientX - this._ d eltaX } _handleSw ip e() { const t =  M ath.abs(this._deltaX );  if  (t  <= 40) return ;  const e = t  /  this . _deltaX ;  this._deltaX = 0 ,  e  & & m(e >  0   ?  t h is ._confi g. rightCallback : t his._config.leftCallback) } _ini tEv ent s( ) { this._sup portPoi n terEvents ? (P.on(this._element, "poin te rd own .b s.swipe ", (t = >   t h i s . _s tart(t))), P.o n(thi s ._element ,  "pointerup.bs.sw ip e", (t => this._end(t))), th is._element.cla s sList.add("pointer-e v ent")) : (P.on(this._ele m ent, "touch s t art.bs.swipe", (t =>   this._start(t))), P.o n( this._element, "tou chmove.bs.swipe", (t = >  th is._move(t))), P.on (this._ ele ment, "touchend.bs .s wipe", (t => this._e nd(t)))) } _eventIsPointe rPe nT ouch(t) { retur n this._supportPoin terEvents && ("pen" === t .po in terType || "touch" === t.poi nterType) } static  i sSupported() {  re turn "ontouchstart" in documen t .documentElement || navig a tor .maxTouchPoints > 0 } } const G = "next" , J = "prev", Z  = "lef t", tt = "right", et = " sl id .bs.carousel", it = " carouse l " , nt = "activ e" ,  st = { ArrowLeft: tt, ArrowRight: Z },  ot = { interva l:  5 e3, keyboard: !0, pause: "hover", ride:  !1, touch: ! 0,  w r ap: !0  },  rt = { interval: " (n umber|boolean) ", keyboard: "boo le an", pause: "(string|boolean)",  ride: "(boolean|s t ring)", touch:  " boolean", wrap: "boolean"  };  c lass at extends z { con s tr uctor(t, e) { sup e r(t, e), this._inter va l  = null, th i s. _activeElement = null, this._isSliding = ! 1, this .touchT i meout = nu l l,  this._swipeHelper =  null, this._indicatorsElement = Q.find O ne(".carousel-in d icators", this._element), this._ad d EventListeners(), this._confi g .r ide === it && this.cycle()  } stat ic get  D efault() { return ot  } static get DefaultType () { return rt } static  get NAME() { return "carousel" }  next()  {  this._slide(G) } nextWhenVisible() {  !document.hidden && a(thi s ._ element) && this.next () } prev() { this._slide(J) }  pause()   { this._isSliding   && s(th i s._element), this._ cl earInterval() } cy cl e()  { this. _clearI n terval(), this._updateInterval(), this._interval =  setI nterval((() => this.n e x tW henVisible()), this._config. i nterval)  }   _mayb e En ableCycle() { thi s._conf ig.ride   && (this._isSlidin g   ?  P. on e ( t hi s._element, et, (()  = >  this.cycle())) : th is .c ycl e( )) } to (t) { c o nst e = this._getItems ( ) ;  i f (t > e.length - 1 || t  <   0) return; if  (t his._isSli ding) return void P.one(th is._e lement, et, (() => thi s.t o (t) )) ; const i = this._getItemIndex(this._getA ctive() );  if  ( i = == t) r eturn;  c onst n = t > i ? G : J;  this._slide(n , e[t]) } dispo s e()  { this._swipeHelper && this._swipe Helper.dispose(), s u pe r.dispo s e ( ) } _configAfterMerge ( t) { return t.defaul t I n t erval = t.interval,  t  } _addEventListeners () { this._config.k eyboa rd && P.on(this._el ement, "keydown.bs. carousel", (t => this._ ke y down(t))), "hover" == = t his._config.pause &&  (P.on(this._element,  "m ous eenter.bs.carou s el" , (()  =>  t his.pause())), P.on( t hi s._element,  " mouseleave.bs . carousel", (() => this._maybeEnableCycle()))), t h is._config.t o uch && U.isSupported() && this._addTouchE ventListeners( )  } _addTouc h EventListeners() { for (const t  of Q.find(".c a rousel-item img" ,  this._element ))  P.on(t, "dragstart.bs.carousel ", (t => t.pre v entDe f ault())); const t =  {  leftCallb a c k:  ( )   = >   t his . _ s l i d e(this._directionToO r der(Z)), r i g htC a l l b ac k :  ()   = >  t h i s._slide(this._directionT o Order(tt)), endCallback: ( )  = > { "ho v er" === this._config.pause & & ( th is.pause( ),  this.tou c hT imeout &&  c learTimeo u t( this.to uch Time ou t), this.touchTim eo ut = setTimeo ut( (( ) => this._maybeEnableCycle()), 500 + this._co nfig.i n t erval)) } };  th i s ._swipeHelper  = new U(this._element, t) } _ keydown(t) { if (/input|textarea/i.tes t(t.targe t.t a gName))   return;  co nst  e  = st[t.key]; e && (t.prev entDefa ult(), this._slide( this._d i rectionToOrder(e))) } _get I t emIndex(t) { return this._getItems().i ndexOf(t )  } _setAc tiveIndicatorElement(t) { i f  (!thi s._ indicatorsElement) retur n; const   e = Q.find One(".active", this._indica t orsElement ); e.classList.remove(nt),  e.re moveAttribut e("aria-current"); const i =  Q. fi n dOne(`[ d ata-bs-slide-to="${t}"]`, this._indi cat orsElement); i  && (i.classList.add(nt),  i.s etAttr ibute("a r ia-curr en t ", "true"))  }   _updateInterv al ( ) { const t = this._activeElem en t   || this ._get Active( );  i f  ( ! t) retu rn; const e = Num ber.par seInt(t.g et Attribute("data-bs - interval"), 10 );   this._co nfi g.interval = e || thi s ._c onfig.defaultInter v al  } _slid e (t, e = nul l)  { if (this._is S liding)   retur n ;  const i = this._ge tA c tiv e(), n = t === G , s  = e   ||  b(this. _g etItems(), i, n, this._con f ig.wrap); if (s === i) retu rn; const o = this. _g etItemIndex(s), r = e => P.trigger(this._element,  e, { relatedTarge t: s, direction: th is ._orderToDire c tion(t), from: this. _ getItemIn d ex(i), to: o }); if (r(" s lide.bs.c a rousel").defaultP r evente d) return;   if (!i | |  !s) return; co n st a = Bool e an(this._in t erval) ;  t his.pause(), this._isS li ding = !0, this. _setAct iveIn d ica to rElement(o), this._a ct iv e Element = s; const l = n ? "carousel-item-start" : "carousel-item-end", c = n  ?   "ca rousel-item-next" : "c ar ousel-item-prev"; s.class L ist.add (c ), d(s ), i.cla ss List.add(l), s.classLi st.add( l) , this._queueCallback((()  => { s.classList.remove(l, c), s.cla ssList. add (nt), i.classL ist.remov e(nt, c ,  l), this._isSliding  = !1, r(et) }), i, this._isAnimated ()), a && this.cycle() } _isAnim ated() { return this._ e le ment.classList.contains("slide") } _getActive() {  retu rn Q.findOne(".active . car ousel-i t em", this._element) } _getI t ems() { retur n Q.find(".carousel-ite m" ,  this._element) } _cl e arI nterval() { this._interval && (clea rInterval(this._interval), this ._in terval = null) } _dire c tio nToOrder(t) { return p()  ? t === Z ? J : G :  t  === Z ? G : J  } _o rderToDirection(t) { r e turn p() ? t === J ? Z  :  tt :  t  = == J ? tt : Z } static  j QueryInterface(t)  { retu rn  this.each((function () {  const e = at.getOrCreateInstance(thi s, t);  if ("nu m ber" != typeof t) { i f ("string" == typeof  t ) { if (void 0 === e[t] || t.startsWith("_") ||  "constructor" ===  t) throw new TypeError(`No meth od named "${t}"`); e[t]() } } else  e.t o(t ) })) } } P.on(document, "click . bs.caro u sel.d a ta -api", "[data-bs- sl ide], [data-bs-slide-to]", (functio n ( t ) { const e = n(this) ;  if  (!e || !e.classList.c o nta ins(it)) return; t.prev en t Default(); const i =  a t.g etOrCreateInstance(e), s = this.get Attribute("data-bs-slide-to"); r eturn s ? (i.to(s), void  i._maybeEnableCycle( ))  : "next" === B .ge t DataAttrib u te(this, "slid e ") ? (i.next(), void i._maybeEn a bleCycle()) : (i.pre v (), void i._may b eEnableCycle()) }) ), P.on( w indow, "load . b s.carousel.data - api", (() => { const t = Q.find('[data-bs-ride="carousel"]');  f or (con s t e of t )  at.getOrCreateInstan c e( e) })), g(at); const l t = "sh ow", ct   = "collapse", ht = "collapsing",  dt  = '[data-bs-t o ggle="c o llaps e "] ', ut = { parent: null, toggle: !0  }, ft = { parent:   " (null|element)", toggle:  " boolean "  }; class pt extends z { constructor (t, e) { super(t, e),  this._isTransit ioning = !1, this._triggerArra y  = []; const n =  Q .find(dt); for (const t of n )  {  c onst e = i (t) , n = Q.find(e ).filter((t => t === this._elem ent) ); null !== e && n.length && th is . _triggerArray.push(t) } t h is._ini t ial izeChi ldren(),  t his._con fi g.parent || this._a dd AriaAndCo l laps edClass(this._trigg er A rray, t h is._isShown()), this._config .to gg le && thi s. toggle()  }  s tatic g et  Defau lt() { return ut } static get DefaultType() {  return   ft  }   static get NAM E() { return "collapse" } tog gle () { this ._i s Show n()  ? this.hide() :  t his.show() } sho w( ) {  if  (this._isTransitioning | |  this._isShown()) re turn; l e t t = [] ;   if (this._ con fig.parent &&  (t = this._getFirstLevelC h ildren( ". collapse.sh ow,  .colla pse.co l lapsin g" ) .filter(( t  = > t !==  th i s._elem en t )).map( (t   => p t.g etO rCre at e Instance (t ,  { tog gl e : !1 })))), t.leng th   && t[0]._is Tr a nsitionin g)   return; if ( P. t rigger(this._elemen t,  "s h ow.bs.collapse").d e fau l tPr e v ent e d) r etu rn;  fo r  (const e of  t) e.hide(); const e =  th is . _getDimension(); th i s ._e l eme n t .cl a ssLi st. remo ve ( ct), this._el em e nt.clas sL i st.add(ht),  th i s._element.st yl e [e] = 0 ,  t his._addAria An d CollapsedClass (t h is._trig ge r Array, !0), t hi s ._is Tra nsi tio nin g =  !0 ; c onst  i = `scroll${ e [0].toUp p erCase() +  e. slice(1)}`; this. _ queu e Callback((() = >  {  this ._ is Transitioning  =  !1, this._element. cla ssList.remove ( ht),  t his._element.cla ssList.a dd (ct, lt), thi s. _eleme n t.style[ e ] = "", P.trig g er(this._element, "shown.bs.colla ps e") }), this._elemen t , !0), this._e l ement.style[e] = `${this._element[i]} px ` } hide() { if (this._i s Transitioning  | | !thi s._isShown( ))  return; if (P.tr ig ger(this._element, "hide.bs.co ll apse").defaultPrevented)   return;  c o nst t  = this._getDi mension( );  this._ element. sty le[t] =  `${ t his._ e lement.g etBoundingClientRect()[t]}px`, d(this._el eme n t), t h is._element .c las s L ist.add(ht), th is ._e l e ment.classList .remo ve (ct,  lt ); for (const t of this ._t riggerArray) { const e = n(t); e  &&   !this . _isSh ow n(e )   && this._addAriaAndC o llapsedClass([t],  ! 1)  }   th i s. _isT ran si tioning  = !0, t his . _elem e nt.style [ t ]  = "",  t his._queu eCallback((() => {  this. _isT rans itio ning =  !1,  t his._e l ement.cla ssList.rem ov e(ht), thi s. _e lement.classList.add(ct), P.trigger(this._ele ment, "hid den.bs.c o ll apse") }), this. _e lement, !0) } _isShown(t = this._elem ent) { re turn t.c la s sList.contains(lt) } _configAfterMerge(t)  {  r eturn   t.toggle = Boo l e an(t.toggle), t .p are n t  = r(t.parent), t } _getDimension() {  r eturn this. _ element.classList.cont ain s( " collapse-ho r izo n tal ") ?  "wid th " : " he ight" } _initializeChil dre n() { if (!this._config.parent)  ret u rn; const t = this._ getF irs t Le velChildr en(dt); for (cons t  e of t) { cons t  t = n(e); t && this._ a ddAria A ndCollaps ed C lass([e],  t h is._isShown (t)) } } _get F irstL e velChildren(t) { const e  = Q.find(" :s c op e .colla p se .collapse", this._c onf i g.parent); ret u rn  Q .find(t,  this._config. p arent).filter((t =>   !e.includes(t ) )) } _ addAriaAndCollapsedClass(t, e) { if (t.lengt h ) for (const i  o f  t ) i.cl ass L is t. t oggl e("col lap s ed ",   !e),  i.se t Attribute("aria-expanded",   e )  }   st a ti c jQu er yI n terface(t) {  c o ns t e = {}; r e turn "string"  = =  t y peof t && /sho w | hi de/.test(t)  & & (e.toggle =  !1 ),  this. e ach((f u nctio n  () { const i = pt.getO r C reate In st a n ce(this ,  e );   i f ("string"  = = t y pe o f  t) {  i f  (v o i d 0 === i[t ] ) t h ro w   new Typ e Er r o r(`No me t ho d name d  "${t} "` ); i[t] ()  } } ))  } } P . o n( documen t ,  " click .b s. co ll a p s e.data-api", d t , (fu n ction  ( t ) { ("A" === t . t arget.tagName | | t.delegateTarget && " A "  == =  t .d e legateTar get.tagName) && t . pr ev e nt De f ault(); co n st  e = i(this),  n  = Q.find(e) ; for  (c onst t  o f   n) pt.getOrCre at e Insta n ce(t, { toggl e:  !1 }).toggle()  }) ), g(pt); var g t = "t op" ,  mt  =  "bott o m", _ t  =  " r ig ht ",  bt = "left", vt  = "au to" ,   yt = [gt, mt ,  _t, bt ] , wt  = " s tart",  A t  = "end", Et =   "clippingParents", Tt = "viewpor t ", Ct = "poppe r ", Ot  = "refere nce",  xt = yt.reduce((fun ct i o n (t, e) { ret u rn t.c oncat([ e  + "-" + wt, e  +  "-" + At])  } ), []), kt = [].concat(yt, [vt]) . reduce((functi o n (t,  e) { r etu rn t. c o n cat([e, e + "- "  + wt, e + "- "  + At])   }), [] ) , Lt  =  "befo r eRead", Dt = " r ead", St = " af terRead ",  It = "beforeMa i n", Nt = "main " , Pt   = "afterMain",   jt  = "bef o reWrit e " , Mt =   "w rite" ,  Ht = "af ter Write", $t = [Lt,   Dt, St , It, Nt ,  Pt, jt,  Mt , Ht] ;  functi on  Wt(t)  {  return  t ?  (t.nodeName ||   " " ) .t oLowerCa se( )  : nu l l } function Bt(t) { i f  (null == t) return win do w; if  ( "[objec t W indow]" !== t.t oString()) {  var  e  = t.o wne rDocum en t;   return e  && e .d efaultVi ew || window } return  t  }  f uncti o n Ft(t )  { retur n t  instanceof  B t(t).E lem ent || t inst an ceof El eme nt } func ti on  zt (t) { return  t instanceof Bt(t).HTMLElement || t  in s ta nceof HT MLE lement } fun ct i on  qt(t) {  r eturn  "un defined"  != typeof   S hadowRoot &&   (t instance of B t( t ) .ShadowRoot ||   t inst anceof  ShadowRoot) } const  Rt   =  {  n ame :  "applyStyles" ,  en a bled: !0, ph ase:  "wr i te", fn: funct i on (t) { var e = t.state ;  Obj ec t.keys (e .elemen ts ).for E ac h( ( function (t) {  v a r i = e.styles[t] || {},  n =  e . attributes[ t ]  | | { },  s  = e.ele m e nts[t ]; zt(s)  && Wt(s ) & & (Obj ect.ass ign (s.style , i ) , Obje c t .keys(n) . f orEach( ( f unction (t )   { var e = n[t]; ! 1   === e ? s.removeAttribute(t) :   s .setAttribute(t,   ! 0 ===  e   ? ""  : e) }))) }))  } ,   effect:  f unction  (t )  {  va r  e =  t .state,  i =  {   popper: { position :  e.opti on s .strategy,  l eft: "0" ,  top: "0", margin:  "0" }, a r row: { pos ition: "abs olu t e"   } ,  refe renc e: {} }; ret urn   O bject. a s sig n(e . e le m ent s . pop per . s ty l e,  i . popper), e.styles =  i , e.elements.arrow & &  Obj e ct.assign(e.elemen t s .arr o w.style, i.arrow), fu n c tion ( )   {   Obj ect . k eys(e.elements ). f o rEach((functi on   ( t)   {   v a r   n  =   e .elem e n t s [t],   s = e . a t t r i bute s [ t ]  | |  {},  o  = O b j ec t.keys(e.styles.ha s Own P ropert y (t ) ? e.styles[t ]   :  i [t ] ). reduce( (functio n ( t , e)  {  return  t [ e] = "", t }), {}) ;   zt(n)  &&  W t (n) && (Object.assign ( n. styl e,   o) , Object. ke ys(s).fo rE ac h ((function (t) { n.removeAttribute(t )  }))) })) } }, require s:  [ "computeStyles"]  } ;  fu nction Vt (t) { return t.spl it("-")[0] } var  Kt = Math.max, Qt =  M ath.min, Xt =  M ath.round; function Yt ( ) { va r   t =  navigat or.use rAgentD ata; re turn nu ll !=  t &&  t. brands ? t.bra n ds.map ( ( function  ( t ) { return t. b r and + "/" +  t . version })). j o in(" ") :  n a vigator.use r A gent } function Ut ( )  { return ! / ^ ((?!chrome|andr o i d).)*safar i / i.te s t (Yt())  }  f u n c ti o n  Gt( t ,  e, i)  {  v o i d  0   = == e && (e  =  !1), vo i d 0  = ==  i   &&   ( i  =  !1 ) ;  v a r n  =   t.ge tBoun d ingClientRect(), s = 1 ,   o = 1; e && zt(t) && ( s   = t . o ffs e t Width >  0  &&   Xt(n. w idth)  /   t.offsetWidth | |   1, o = t.offse t Hei ght >  0  && Xt(n .he ight )  / t.offsetHeig ht  || 1); va r r   =  (F t (t) ? Bt(t) : w i n dow).visualView po rt,  a  =  ! Ut( )  &&   i,  l =  ( n .le ft  +  (a   &&  r  ?  r .o f fse t Le ft : 0)) / s, c  =  (n.top + (a && r ? r.o f fsetT o p : 0)) /   o,   h   =  n.w i dth  /  s ,  d =  n .h e igh t  /  o ; r etu rn  {   wid t h:  h ,  h eig h t:  d, top: c, righ t : l + h, bottom: c + d ,  left :  l, x: l ,  y :   c   } }   functi o n  Jt(t) { var e  = Gt(t),  i  =   t. offs e t Wi dth ,   n = t.of fse t Heigh t ; re t u rn M a t h.abs(e.width - i) <= 1  & &  (i = e . wi dth) ,  M a t h. ab s( e.he i gh t   -  n )  <=  1  & &  ( n  =   e. he ig h t) , { x: t . offs e t Left ,   y: t.offsetTop, w id th:   i, hei g h t : n   } }  fun c t i on  Z t(t , e) { var  i  = e.getRootNode &&  e .g et R o otNode(); if   ( t .conta i n s (e))  r eturn !0; if ( i   & & qt(i ) )   { var n =  e;   do { if (n && t.i sS ame N ode(n) )   r e t urn  ! 0;  n =  n . p a r entN o de  || n.host }   whi le  ( n) } ret u r n !1  } function te(t)  { retur n B t(t).g etComputedStyl e(t ) } func tio n  ee(t )  { retur n   ["table",  " t d", "th"].indexOf( W t (t)) > = 0   }  fu n c tion ie(t)  {   return  (( F t( t)   ?  t.ownerDocumen t   : t.do cum e nt )  | |   window.doc ument).documentE lement } f unction ne(t) {  return  "html" === Wt(t) ?  t : t.assi gnedSlot || t.p arentNode || (qt (t ) ? t.ho st : nu ll)  || ie(t) } functi on  se( t)  { return zt(t) && "fixed" != =  te(t).position ?   t.offsetParent :  null } function  oe(t) { for (var e =  B t (t), i =  se(t); i && ee(i) && "static"  === te(i ).position;)i = se( i); retur n  i && ("html"  = == Wt( i) | |  "body" === Wt(i) && " st atic" === te(i) . position) ? e : i  || function (t ) { var e = /firefox /i . test(Yt( )); if (/Trident/i.tes t(Yt()) & & zt(t) &&  "fixed" = ==  te(t).positio n ) retu rn null; var i = ne ( t); for (qt(i) &&  (i = i.host); zt(i)   && ["html", "body"].inde xOf(Wt(i))  <  0; ) { v ar  n  = te( i ) ; if ("n on e"  !== n.t r a nsfor m || "none" !== n .perspec tiv e || " paint" = ==  n.contai n  | |  -1 !==  ["transf orm " , "pe r spective " ] .indexOf(n. w i llChange)  | |  e && "fi l t er" == = n . wi ll C h ange || e   & & n.fi lte r  & &  " n one" !== n.filter) ret u r n i; i = i.parentNode } return null  }(t) || e } function re( t) { ret ur n ["top", "bottom"] .in d exOf(t) >= 0 ? "x" : "y" } f unction a e(t , e,   i)  { return Kt(t, Qt(e, i)) }  function  le(t ) { retu rn   O bj ect.assign({}, { to p:  0 , right: 0, bottom: 0, left: 0  }, t) } f unc tion   ce (t, e) { return e.reduce((funct ion (e, i ) {   re turn  e[ i]  = t,  e   }), { }) } con st he  = { nam e: "arr ow", e nabl ed: !0,  ph ase: "main", f n : function (t) { var e, i = t.state, n = t .name, s  = t . options, o =  i. e lement s . arrow,  r = i .mod ifiersD at a.popperOffset s , a = Vt(i.placement), l = re( a), c = [ bt,   _t].indexOf( a)  > = 0 ? "height"   : "wi d th"; i f (o & &  r) { var h  = function (t , e) { ret urn le("numbe r "  != typeof (t  =  "function" == typeof   t ? t(Object.ass i gn({}, e.rects ,  { pl a cement :   e.placement   } )) : t) ? t  :   ce(t, yt)) } (s.pad ding, i), d = Jt(o), u = "y" === l  ?   g t  :  bt, f = "y" = = = l ?  mt : _t,  p = i. rects.reference[c] + i.rect s. r e ference[l] - r[l] -  i .rect s. poppe r [ c ], g = r[ l ] - i.rects.re fe r ence[l ], m =  oe ( o) ,  _  = m  ? "y "  === l   ?   m.c lient He ig h t || 0 : m.clien t Width  | | 0 : 0,   b  = p /   2   -  g / 2, v = h[u], y = _ - d [c ] -  h[f] ,   w  =  _  /   2  - d[c] / 2  + b, A =   a e (v, w, y), E = l; i . modifiersData[ n ] = ((e = {})[E] = A, e. ce n terOf fset  = A  - w , e) }  },   effect:  functio n ( t ) { var  e  =  t.state, i =  t. op t ions.ele men t,   n = void 0  ===  i   ? "[d a ta-pop p e r-arro w ] " : i; null != n  & &  ("string" !=  t y peof n || (n =  e . el e m en ts .po p p e r.queryS e l ector(n)) ) &&  Z t(e.e le me nt s. popper,  n)  & &  (e . elements.arro w   = n) }, requ i res: [ " popper Of fsets"] ,  re q u iresIf Ex i s ts:  ["p r event O verflow" ] } ;  f uncti o n de( t)  { retur n t .sp lit("-")[1]  }  var  u e = { top: " auto",   right:   "auto", botto m: "auto " , lef t : "auto" }; fun ction f e (t) {  v ar e, i = t.po pper, n   = t.popperRect , s = t. p lacement, o = t .va r iation,  r  =  t.off s ets,  a   = t.positio n,  l  = t.g p u Accele r a tion,  c   = t. ad ap t ive, h = t.round O ffsets ,  d = t. i s Fixed, u = r.x, f  = void 0 ===  u   ? 0 : u, p =  r .y ,   g = void 0 == =  p  ?   0 : p, m = "functi on" == typeof h   ?  h({ x: f, y:  g  } )   : { x: f, y: g   };  f   = m.x, g = m. y ; var  _   = r.hasOwnPro perty( "x"),  b  = r. ha sOwnProperty (" y" ),  v = bt, y = gt,  w   = window; if  ( c)   { v a r A =  oe (i), E  =  "c li en t H eight", T   = "clientWidth " ; A == =   Bt(i) && "st a t ic" !== te ( A  = ie(i)).po s i t i on &&   "abso l u t e " ===   a &&  ( E  =  " scrollH e i g ht", T  =  " s c rol l Width"),   ( s  === gt  | |  (s ===  bt   || s ===   _ t )  &&  o  == =  At) &&  (y  = mt,  g -= (d   & &  A  = ==  w  & & w.visu al Viewpo rt ? w.v i s u al Vie w port.hei gh t  :  A[E])  - n.hei g h t ,  g * =  l ? 1 :  - 1 ),  s !==  bt && ( s   ! ==  gt  &&  s  ! == mt  | |   o !==   At) | |  (v =  _t ,  f  -= ( d  &&  A  = = = w && w . visualVi ewport  ?  w .visualV iewp o rt.w i dth :   A [ T])  -  n. width,  f *= l  ? 1  :  -1)   } var   C ,  O =   Ob j e ct.assig n ({ position: a  } ,  c &&  ue) ,  x  =   !0 = == h  ?  f u n ction (t) {  v a r e =  t.x ,   i = t.y, n  =  w i n dow.deviceP i x elRati o | |   1; return  {  x :   Xt(e * n) /   n  || 0,  y:   X t( i  *   n ) / n || 0 } }( {   x: f,  y:  g   })   :  {   x: f, y: g }; ret u r n f =  x.x ,   g  =  x . y , l ? Object.a s s ign({} , O ,  ( (C   =  {})[y] =  b   ? "0"  : " " ,   C [v ]   = _ ? "0" :  " ", C.tra n s f orm =  (w.d e v i ceP ix e lR a tio   | | 1) <= 1 ? "tr a n slate(" + f  +   " px,   "  + g + " px) "  :  "t r ansla t e3d(" + f + "px,  " +   g  + "px,  0)" ,  C))  :  Object.as s i gn({}, O, (( e = {})[y] = b ? g + "px" : "",  e[ v ]  = _ ?   f + " p x"  : "", e.tra n sform = "", e)) }  con s t pe = { nam e:  "com pu te Styles ",  enabl ed:   !0 , ph a se: "beforeWr i t e", fn: func tion  ( t ) { v a r  e = t.state, i =  t.o pt i ons,  n  = i. gp uAc celeration,  s  = void 0  === n  || n, o   = i.adaptiv e, r = vo id 0 ===   o || o, a =  i.roundOff sets,  l  = void 0  === a ||   a,  c = {  p lace ment: Vt(e.pla c ement),   variati on: de(e . placemen t ), pop per :  e.elem ent s .poppe r , poppe r R e ct: e.rects.popp er , gpuAcceleration: s,  is Fi xed :   "fixed" === e.options.str a t egy  }; null !=  e .modifie rs Data.popp erOffsets & & (e.style s .po p p er = Object.assign({ },  e.s t y l es. po p p e r,   f e (Obj ect.a s sign( { }, c,  { offse ts: e.mo d ifiersDa t a.popperO ffset s, pos i tion:  e .option s.stra tegy, a d aptive:   r, roun dO f f sets: l })))), null !=  e. mo dif ie rs Da t a.arr o w &&  (e.styles.arrow = Object.assign( {},   e.sty l es.a rrow, fe(Objec t. a s s i gn( { } , c,  { offsets: e. mo d i fie r sDat a.ar ro w, p o s iti o n: "abso l ute", adaptive :  ! 1, rou ndO f fs et s : l  })))) ,  e . a ttributes.po p p er = Object . a ssign({}, e.att r i butes.popp e r , { "data-popper- p l acement": e.placement })   } , data : { }   };   va r   ge = {   p a s s i ve :  !0 }; const me = {  na m e: "eventLis ten e rs" ,  en a b led: !0, phase: "w rit e ", fn: function ()  {  } , ef f ect : functi on  ( t ) {  var  e  = t.state, i = t. ins ta n ce, n = t.o p tions ,  s = n.scr ol l, o = vo id  0 === s || s ,  r = n.re s ize, a = v o id  0 == = r || r, l = Bt(e.elements.popper),  c  =  [ ].concat(e. s crol lPa r ents.ref e r ence,  e.scro llParent s.p opper) ; retur n o  && c.fo rEa c h((fu n ction (t )   { t.addEve n t Listene r( "scroll", i.update, ge) })) ,  a  && l.a d dEventListe n e r("res ize " ,  i. u p date, ge),   f unctio n ( )  {  o   & & c.forEach((function   ( t) { t.rem o v eEventListe n e r("scroll", i.u p d ate, ge) })),  a   && l.removeEventL i s tener( "re s iz e" ,   i.update, ge) } }, data:   { } }; var _e = { left :   "right " ,   ri gh t:  " le f t ", botto m:  " to p", to p:  "bo ttom"  };  funct i on be( t) { r eturn t .r eplace (/le f t|right|b o t tom|top/g, (function (t) { ret urn  _ e [t] })) } var ve = {  sta rt :  "end " , end: "st ar t" }; fun ct ion ye(t) { r et urn t.re pl ace(/start|end/ g,  (function (t) { retur n  v e [t ] } )) }   f unction we(t) { va r   e = Bt(t); retu r n  { scrol l L eft :   e.pag e X Of f s et, scrol lTop :  e.pa g eYOff s e t } }  f u nctio n A e(t )   { re turn Gt(ie(t)) .l ef t   +   we(t).s c rollLeft  }   funct i on Ee(t) {  v ar e = te (t ), i = e.over fl ow, n = e.ov er flowX, s   = e . o v e r f lo w Y;   r e tu r n / auto | scro ll |o v erlay|h idden / .test( i   + s  +  n )  } function  Te (t)   {  return ["ht ml ",  "bo dy ",  "#document"].inde xOf ( Wt(t)) > = 0  ?   t .o w n erD ocume n t.body :  z t (t ) & & E e(t) ?   t : Te(n e(t ) ) } f u nction Ce(t, e)  { v a r i;  v oid 0 ===  e  &&  (e = []); var n  = Te(t), s = n ===  (n u ll == (i  =  t.ow ne rDo cument)  ?  v oid 0 :  i . b o d y ) ,  o   =  B t(n), r  =  s ? [ o].co ncat(o.visu alV i ew port || [], Ee(n) ? n : [ ] ) :  n, a = e.c o nc at(r);  r etu r n  s ? a : a.concat( Ce(ne(r)))  } fun c tion O e( t )  { return Objec t. as s ign({}, t, {  lef t :  t. x ,  t op :  t .y,   righ t: t. x  + t.wid t h, b ottom:  t.y +  t .height   }) }  functi on xe(t,   e, i) {  r etur n e = == Tt  ?  Oe(fun c tio n   (t, e) { var i   = Bt(t ), n  =  ie( t), s = i.visualVi ewp o rt, o = n.c li e ntW i dth, r =   n .clie ntHeigh t, a = 0 , l  = 0;  if (s)  { o = s.width, r  = s.height; var c =  Ut( ); (c ||  !c   && "f i xed" ===   e ) && (a   =  s.offsetLeft, l =   s .offsetTop) } r e t urn { width: o, height: r, x: a  +   Ae(t) ,  y: l } }(t, i) ) : Ft(e) ?  fu n c tion  ( t, e) { var  i  = G t ( t, !1 , " f i xed"  == = e ) ;  retur n   i.top  = i.top + t.client T o p, i.left = i.left + t.cl ie ntLeft, i.bottom = i .t op + t.clientHeigh t,  i.right = i.left   +  t.clientWidth, i.wi d th = t.clientWidt h, i.height = t.clie n tHeight, i.x = i.left, i.y = i. to p, i }(e, i) : Oe(func t io n  ( t)   {  var  e, i = ie (t), n =  we (t), s  = null  == (e =  t.ownerDocument) ?  vo id 0 : e .bo d y, o  =  Kt(i.sc r o llWidth, i . c lientWi d t h, s ? s. s c rollWi dth   :  0,  s   ?  s . clientWidth : 0), r  =  Kt ( i.scrollHei g ht, i.cl ien tH ei g ht, s   ? s.sc r o llHe ight : 0, s ?  s. c l ie n tH e i ght : 0),  a  = -n.scr o llLeft + Ae(t), l =  - n .scrollTop ;  re t ur n   "rtl"   = == te (s || i) . d ir ec t i on  & &  ( a  += K t(i.clientWidt h,   s   ?  s. cl i e n t Wi dt h  :   0) -  o), { w idt h : o , he i g ht: r, x: a, y:   l  } } ( i e(t) )) }  f unction ke(t) { var e, i = t. re ference, n = t.element, s = t.pl ac em ent, o = s ? Vt(s) : null, r =  s  ? d e(s) : null, a = i . x   +  i. w i dth /  2 - n.width / 2 , l = i. y +  i.hei ght / 2  -  n.height  /  2 ; swi t ch (o) {   c ase gt:  e = { x: a, y: i. y  - n .height };  break; case mt: e  = { x:  a, y: i.y + i.h eight };  break; case  _t: e = {  x: i.x + i .w id th, y :  l  };   b reak;  case bt: e = { x:  i.x - n .wi dth, y : l };  bre ak; defa ult :  e =  {  x: i.x,   y : i.y } }v a r  c = o  ?   re(o) : nul l ;  if (n ull   !=  c )   { var h =  " y " ===  c ?   "h ei g h t" : "width " ;  switch (r) { c a s e wt: e[c] = e [ c ] - (i[h]  /   2 - n[h]  /   2); br eak ;  c as e   At: e[c] = e[c]   +  (i[h]  /  2   -   n[ h ]  / 2)   } } retur n  e } function  Le (t, e) {  v oid 0 === e  & & ( e   = {}); var i = e ,   n = i.placement,   s  =  v o id 0 = = =  n  ? t . p lac e ment   :  n, o = i.strategy, r = void 0   = == o ? t.strategy  :   o, a = i.bounda r y , l = void  0  === a ?   Et : a, c = i.rootB oundary,   h = void 0  === c ? Tt  :  c ,  d   = i.elem en tContext ,   u = void  0  === d ?  C t   : d, f = i.altB oundary,  p  = void 0   != = f   & & f, g = i.padding, m  =  void 0 === g ? 0 : g, _ = le("numb e r" !=   t y pe of  m   ?  m  : c e (m , y t )), b  =   u = ==  C t  ?   Ot  :   Ct,  v  =   t. r ect s . pop per ,   y = t.el e ments[p  ?   b : u ] ,   w  = fu n c t i on (t ,   e ,  i, n )   {  v a r   s =  " c lipp i ngPar e n t s"  == =  e ?  f unctio n   (t) { var e = Ce( n e ( t) ) ,  i =  [ " absolu te ", "fix e d" ] . indexOf(te(t).position) >= 0 && zt( t ) ? oe(t) : t; return Ft(i) ? e.filter((fun c t ion  (t ) { re tu rn Ft(t )  && Zt ( t,   i ) &&  " b ody"  ! = = Wt( t) }) ) : []   } ( t ) :  [ ] . c o n c a t (e), o = [ ] . c o n c a t(s, [i]),  r   =   o[0],   a   =   o . r e duce((func t i o n   ( e , i) { var  s   = xe(t, i, n); r et urn e.top = Kt(s.top,   e . t op) , e . r ight = Qt(s .r i g ht, e.right) ,  e . bo t t om =  Q t( s .bot to m ,  e.bot t om),  e . l ef t   =   K t (s . l eft,   e.lef t ) ,   e   }) ,  x e( t ,  r, n )) ;  re turn   a. widt h   =   a .r igh t  - a.l e f t,  a.h e i gh t  =  a. b ott om  -   a. t op,  a . x = a .l e ft,  a. y   = a.top,   a }(Ft(y )  ?  y   : y.c on t ex t Elemen t  | |  ie( t.el ements.popper),  l ,  h,  r) ,  A  = G t( t . elemen t s.ref e r e nc e) ,  E   =  k e( {  refe r ence:   A,   element: v ,  s tr a te g y: "a b solut e ",   placement :  s  }) ,   T  =  O e(Object .as si gn ( {}, v ,  E)),  C  =  u === Ct   ?   T   :  A, O  =  { t o p: w . to p  -  C.t o p  +   _.to p, b o tto m: C . bo t to m  - w.bottom + _.bo t t o m,  left: w.left - C .left + _. le ft, right: C.r ig ht   - w.ri ght   +  _. r ight  }, x  =  t . modifi e r sData .o ffset; i f ( u  ===  C t && x) { var k = x[s]; Ob j e ct.keys(O). f orEach((funct io n  ( t ) { var e =  [ _t, mt].indexO f( t)  >= 0 ?  1 :   -1 ,  i  =  [gt,   m t].ind e x Of(t)  > = 0   ?   "y" : "x";  O[ t] += k[i]   *  e   } ))  }  r e tu rn O }  f un ct io n D e( t, e) {  voi d 0 = ==  e &&  (e  =   {} ) ;  var  i =  e,  n =  i . placement,  s  =  i.boundary, o  = i.rootB oundary, r  =   i.paddi ng, a   = i . flipV ariati on s, l = i.allo wed Au toPlacements ,   c  = vo i d 0 ===  l  ?  kt :  l , h = de(n),   d =  h  ? a ?   xt : xt.fil t er(( functi on (t) {  return  de(t) = = =  h })) : yt, u   = d.f i lter((fu n c tion (t)   {  re turn c.indexO f (t) >= 0 }));  0 === u.length && (u  =  d) ; var f = u.reduce (( function (e, i) { ret urn   e[ i] = Le(t,  {  plac e ment: i,  b ou ndar y : s,  rootBoun d ary: o, padding: r })[Vt(i )],   e }), {}); re tu rn O bject.keys(f).sort( (fu n ction (t, e)  {  retu rn f [ t ] - f[ e ]  })) } con st Se = {  name: "fl ip" , enabled : !0, phas e:  "main", fn:  f unc tion ( t ) { var e = t.sta t e , i = t.optio n s ,  n   =  t.name;  i f (!e.modifie rsData [n]._skip) { for  (va r  s = i .ma in Axis, o =  vo id 0 === s || s, r = i.altAxis,  a  =  void 0 === r  | | r, l  =  i .f al l back Place m en t s , c = i.padding, h  =   i.boun dar y ,  d   =  i . rootBoundary, u =   i .altBo und a r y,   f  = i.flipVariati ons ,  p  =  void  0 = = =  f  | | f , g =  i. a l l owedAutoPl acements,  m = e.options.pl ace ment, _  = Vt(m), b = l ||  (_  != = m && p ? fun cti on (t) {  i f (Vt(t) = ==  vt) re t ur n []; var e  =  be(t);  re tu r n  [y e ( t),   e ,  ye(e) ]  }(m) : [be( m)]), v  = [ m ].con c at(b).redu ce ((functi o n (t, i) { r e tu rn t .concat(V t (i) === vt ? De(e ,  { placemen t:  i, boundary: h,   r ootBoundar y: d,   paddi n g: c, flipVariat i ons: p, allowedAutoP l ace ments:  g })  :  i) }),  [ ] ) , y = e. rec t s.ref e rence,  w = e.rects.popper, A = n ew  Ma p , E = !0, T = v[0], C = 0; C < v.l eng t h; C++) { var  O =   v[C] , x  =  Vt(O ) , k = de(O)  === wt, L = [gt, mt]. i n dexOf(x) >= 0, D =  L  ?  " width "  : "height ", S = Le(e, { p l a c ement: O, boundar y:  h ,  rootBou ndary: d, altBoun dary: u, p adding: c } ), I  = L ? k ? _t : bt  : k ?  mt : gt ;  y [D ]  >  w[D]  && (I = be(I)); var N = be( I),   P = []; if  (o &&  P.push(S[x] <= 0), a && P . push(S[I] <= 0, S[ N]  < = 0), P.every((f unct ion (t) { return t }))) { T = O, E =  !1 ;  brea k  } A.se t ( O, P) } if   ( E) for  (v a r  j   =  f u nction (t )  { var e = v .f ind((func t ion ( e ) {  var i  =  A.ge t( e); if (i )  return i . sli ce(0, t) .e very((fu nc t io n  (t)  { return  t  })) })); if  (e) retu rn   T  = e,   "brea k " }, M = p  ?   3 : 1; M > 0   & & "break"  ! == j(M );  M --); e. p l acement != = T & & (e.m odifier sDa ta[n]._skip = !0, e. placeme nt =  T,  e.rese t  =  !0) } }, re q uiresIfExists: ["off set"], data: { _skip: !1 } }; functi on  I e(t, e, i) { return void 0 ===   i && (i = { x: 0,  y: 0 } ), {  to p: t.t o p  -   e.height - i.y, right: t.r ight -  e. wid th + i.x ,  bott o m: t.bottom - e.height   +  i.y,   l eft: t.lef t   - e.wi dth   -  i . x  }   } funct ion Ne(t)  {  return [ gt ,  _ t,  mt, bt ]. some((fu nc tion  (e ) { retur n  t [e ]  > = 0 })) } co n st  P e  =   {  n ame: "h id e ", enabl ed :  !0, phase: "main", requires IfE x ists: ["preventO verf low "] , fn: fu nc t ion (t)  {  va r  e = t.state, i = t.n ame ,  n = e.rects.reference, s = e.re ct s . p opper,  o = e. mod ifier s Dat a.preven tOverflo w,   r =  L e (e ,  {  e lementC ont ext: "ref erence" }),  a  = Le(e, { altBound ary :  !0 }), l  = Ie ( r ,  n ), c = Ie(a, s, o), h = Ne(l), d = Ne (c) ;  e .m odifiersData[i]  =  { referenceClippi ngOf f s e ts: l,   poppe rE s cape Offsets: c, isRef eren ceH idd en:  h,  h a sPop perEscaped: d },  e.at tri but es. pop per  =  Obj ect .as sign({},   e.attributes.popper, { "data-popper-r eference-h idden ": h, "data-popp er- escaped": d })  } } , je = { name: "o ffs et", enabled:  !0 , phase: "main",  req uire s:  ["poppe rOf fsets" ],  fn: f unc tion  (t)  { var e = t.st ate , i =  t.o ptio ns,  n = t.name, s =  i. offset, o  =  void 0  ===  s ? [0, 0 ] :  s, r = kt.reduce((f unc tion (t, i)  {  return t[i]  =  funct ion  (t, e, i)  {  var n = Vt( t),  s =  [bt , gt].inde xOf (n) >= 0 ? - 1 :  1, o  = " function" = = t ypeof i ? i(Obj ect .assign({},  e,  { plac eme nt: t })) : i,  r  = o[0], a = o[1 ];  retur n r  = r  ||  0, a =  (a  || 0) * s, [bt , _ t].indexOf(n) >=  0  ?  { x: a, y: r } : {   x: r,  y: a } } (i,  e. r ects, o), t  } ) , {}), a =  r [ e.placement] ,  l  = a.x, c = a.y; null != e.mo di f iersData.popperOffsets && (e.mo di f iersDat a. p opperOffsets.x += l, e.modifiersData.popperOffsets.y += c),  e. m odifiersData[ n]   = r } }, Me = { n am e : " p opperOffs e ts", enabled :  ! 0,  p hase: "read " , fn: func ti o n ( t ) { var e =  t .state, i = t.n am e ; e . modifiersData[ i ] = ke({ refe re n ce:   e.rects.refe r ence, element:  e . rec t s.popper, str a tegy: "absolu te " ,  placement : e .placemen t }) }, data: {} } , He = {  name: "pr eventOv erf low ", enabled: ! 0, ph ase: "main ", fn: f un ct i o n (t) { va r e = t.state, i =  t.options , n = t.name, s = i .mainAxi s, o = vo id 0 == = s || s, r = i.altAxis, a  = void 0 !==  r && r, l = i.boundary,  c = i.root Boundary, h = i.altBounda ry , d = i.padding, u   = i.tether, f  =  v oid 0 == = u  || u, p = i . tethe rOffset, g =   void 0 === p ? 0 : p, m =  Le(e, { b o undary: l, rootBounda ry: c,  p adding: d, altBoundar y: h } ),  _ = Vt(e.pla cement), b = d e(e.placement) ,  v = !b, y = re(_),  w  = "x" === y ? "y" :   "x", A =  e .modifiersData.popperOff s ets, E =  e .rects.reference,   T = e.rec t s.popper ,  C = "function" == typ e of g ? g(Ob j ect.assign( { }, e.r e ct s, { placement: e .p lacement })) : g , O = " number"   = = typeof C ? {  mainAxis: C,  a lt Axis: C } : Object.assign( { mainAxis: 0, altA xis: 0 }, C), x = e. m od ifiersData.offset ? e. modifiersData. offset[e.placement] : null,  k  = { x: 0, y: 0 }; if (A) { if (o) {  var  L, D = "y"  === y ? gt : bt, S = "y" === y ? mt  : _t, I  = "y" === y  ?  "height" : "width", N  = A[y], P = N + m[D], j = N - m[S], M = f ?  -T[ I] / 2 : 0, H = b === wt ? E[ I] : T[I], $ = b === wt ? -T[I]  : -E[I], W = e.elements. arrow, B = f && W ?  Jt ( W ) : {  w id th: 0, height: 0  },  F = e.modifiersD ata["ar row#per s i stent"] ? e.mo difiersData[" ar row#persistent"].padd i ng : { to p : 0, right:  0,  bottom: 0, left: 0 },  z = F[D], q = F [ S], R =  a e(0, E[I], B[I ] ), V = v ? E[I] / 2 -  M - R - z -  O .mainAxis : H - R - z   - O.mainAxis, K  =  v  ? -E[I] / 2 + M + R + q +  O.mainAxis : $ + R  + q + O.mainAxis, Q   =  e.elements.arro w && oe(e.elements.arrow), X  =  Q ? "y" ===  y ? Q.clientTop || 0 : Q.clientLeft  || 0 : 0 , Y = null ! = ( L = null ==  x  ? void 0 : x[y]) ? L :  0, U = N + K - Y, G = ae(f ? Qt( P, N + V - Y - X) : P, N, f ? Kt(j,  U) : j); A[y] = G, k[y] = G - N } if (a) {  var J, Z  = "x" === y ? gt : bt, tt = "x"  === y ? mt  : _t, et = A[w], it = " y" === w ? "height" :  " w i dth", nt = et   +  m[Z], st  =  et - m [t t ], ot = -1 !== [gt, bt].indexO f( _), rt = null ! =  (J = null  ==  x ? void 0 : x[w]) ? J : 0, at = ot ? nt  : et - E[it] - T[it] - rt + O.altAxis, lt = ot ? et + E[it] + T[it] - rt - O.altAxis : st, ct = f && ot ? function (t, e, i) { var n = a e(t, e,  i ); return n > i   ?  i : n } (at , e t, lt) : ae(f ? at : nt, et, f ? lt : st); A[w] = ct, k[w] = ct - et } e.modifiersDa ta[n]   = k } }, requi resIfExi sts : ["offset"] }; functi o n   $e(t, e, i)  {  void 0 === i && (i = !1) ;   v ar n, s, o = zt(e), r = z t (e) && f un ction (t) { var e = t.getBoun di ng C lientRect(), i = Xt(e.wi dth) /  t .offsetWidth || 1, n = X t(e.height)  /  t.of fsetHeight  ||   1; return  1  !== i || 1 !== n }(e), a = ie(e), l = G t (t, r, i), c =  {  scroll L eft: 0, scrol lT op: 0 }, h = { x: 0, y: 0 }; retu rn (o || ! o  && !i) && (("body" !== Wt(e) || Ee( a)) && (c  =  (n = e) !== Bt(n) && zt(n) ? { scrollLe ft: (s  = n). sc rollLeft, scrollTop: s.scrollTop } : we(n )), zt (e) ? ((h  = Gt(e ,  !0)) .x  += e.clientLeft, h.y += e.clientTop) : a && (h.x = Ae(a))), { x: l.lef t + c.scrollLeft - h.x, y: l.top + c. s c r ol l To p   -  h . y,   width: l.width,   height: l.h eig ht } } function We(t) { var e =  n ew Map, i =  n ew Se t , n = [ ] ;   function s(t)  { i.a dd(t.nam e) , [].con c at(t.requires || [] ,  t.requiresIfExists  || [ ] ).forEach( (f unction  ( t )  { if  (!i.has(t)) {   v a r n = e.get(t); n  & & s(n)  }   })), n.pus h(t) } return t.forEa ch((functi on  (t)  { e.set(t.name, t)  })), t. f orEach((f unction (t) { i.has(t . na m e) ||  s(t) })) , n } va r  Be = {  placement: "bott o m" ,  modifi ers: [], strate gy : "absol ute " }; function Fe() {  fo r (var t = arguments.length, e  = new Arr ay(t), i =  0; i < t;  i ++ )e[i]  = arguments[i ]; retur n  !e.s o me((f unction (t) {  r eturn !(t && "function" == typeo f  t.getBoundingClientRect) }) )  } function ze(t) { void  0   === t && (t = {}) ; va r  e = t,  i  =   e.defau l tModifiers, n = void 0 === i ? [] : i, s = e.defaultOptions, o = void  0 === s ? Be : s; re tu rn func tion (t,  e , i)  {   voi d 0  === i && (i = o); var  s , r, a = { placement: "bo t tom", orderedModifiers: [] ,  o ptions:   Object.assign({}, Be, o), mo dif ie rsData: { },  elements :  {  refere nce : t,  popper: e }, attributes: {}, styles: {} }, l =  [], c   = ! 1 , h = { state: a, se t Op ti ons : functi on  (i) {  var  s = " fu nctio n"  == typ eof i ?  i(a.op t ions) : i;  d() , a.options =  O bject.a s sign({}, o, a.opti on s,  s) ,  a.s crollParents = { ref erence: F t(t) ?  C e(t) : t.contextE l e ment ? Ce(t.contextE le ment) : [], popper: Ce( e)  }; var  r,  c, u = function (t)  {  v ar  e = We(t );  return $t.reduce((f un ct ion (t, i )  { return t.concat(e.filter( (f unction  (t)  { ret ur n t.p has e ===  i  }))) }), []) }((r = [].concat(n, a.options.modifiers), c = r .reduce(( functio n   (t, e) { var i  = t[e.nam e] ; retur n t [e.nam e]  = i ? Object . ass ign({}, i, e, { op t i ons: Object.assign({}, i.option s , e.opt i ons), data: Object.assign({}, i.data, e.d a t a) }) :  e,  t }),  { } ), O bject.keys(c).map((f un cti on  (t ) { ret ur n  c[ t]  }))));  return a.orderedMod ifiers  =  u.filter((funct i on ( t ) { return t .enabl ed  })), a.orde redMod if iers.forEach( (function (t) { var e = t.nam e ,  i = t.options, n = void 0  = ==  i ? {} : i, s = t.effect; i f ("funct ion" == typeof s) { var o  = s({ state:  a , name: e, instance:  h, option s: n }); l . p ush(o || funct ion  ()  { }) } })), h.update() },  forceUpdate:  fun cti on () { if (!c) { var t =  a.elements, e  = t .reference, i =  t.popper; if  (Fe(e, i)) { a.rects = { refe rence: $e(e, oe (i), "fixed" = ==  a.o ptions.st rat e gy), popper: Jt(i)  }, a.reset = !1, a.placement = a.opti ons. placem ent, a.o r deredModifiers.forEach((function (t) { return a.modi fi e rsData[t.name]  =   Object.assign({} ,  t .data) })); for  (var n  =  0; n < a.ord e redModifiers. l ength; n++)if   (!0 !== a. r eset) {   var s = a.orderedModifiers[n], o = s. fn, r = s.options, l = void 0 ===   r  ?  {} :  r , d = s . name; "function"  == typeof o && (a = o({  state: a, options: l, name: d, instance:  h  })  | |   a) }  else a.reset = !1, n = -1 } }  },  u pd a t e: ( s = function () { return new P rom is e( ( f unc t ion (t)   { h.forceUpdate(), t(a) })) }, function ()  { return r | | (r = new Promise((function (t) { Promise. reso lve().then((function () { r = vo id 0 , t(s()) })) }))), r }), destroy : f u nction () { d() ,  c = !0 } }; if (!Fe(t ,   e )) return h; funct i on d() { l.forEach((function (t) { return  t() })), l  = [] } return h.setOptions(i ) .then((f u nction (t) { !c && i.onF ir st U pdate & &  i.onFirstUpdate (t) })), h } } var qe = ze(), Re =  z e( {  d ef aul tModifiers: [ me , Me, pe, Rt] }),   Ve = ze({ def a ul tModifi ers: [me, Me, pe, Rt, je, Se,  He , he, P e ] }); const Ke = Object.freeze(Object.definePro perty({ __proto__: nul l, popperGenerator: ze, detectO ver f low: Le, createPopperBas e:   qe, cre a tePopper: Ve, createPopperLi t e:  Re, top: gt, bottom:  m t,   right: _t, left: bt, auto:  v t , basePlacements: yt, start: wt, e nd :  A t, clip p ingParents: Et, viewp ort : Tt , p o p per: Ct, reference: Ot, v ari ationPlacements: xt, p lac e ments: kt, beforeRead: Lt , r e ad: Dt, afterRead: St, before Ma i n:  It, m ain:  Nt, afte rMain: Pt, beforeWrit e: jt, write: M t, a f t erWrite:   Ht, mod if i erPhases: $t, applyStyle s:   R t, arrow:  he, computeStyles : pe, eventLis tener s: me, flip : S e, hide: P e,  offset: je,  popper Of fs e t s: Me, pre ventOverf low: He }, Sym bol.toStringTag, {  value: "Mo dule" })),  Qe = "dro pdown", Xe  = "ArrowUp" , Ye = "ArrowDown" ,  Ue = "click.bs.dro p down.data-api" ,  Ge = "k eydown.bs.dr o pdown.data-api", Je  = "show", Ze =  ' [da ta-bs-toggle= " drop d own"]:not(.disabled) : not(:disa b led)', ti = `${Ze}.show` ,  ei = ".d r opdown-menu", ii  =  p() ?  "top-end"   : "top- s ta rt", ni = p() ? "top-star t" : "top-end", s i = p() ? "bott om-end"   : "bottom-start", o i = p() ? "bottom-start "  : "bo ttom-end", ri = p()  ? "left-start" : "right-st ar t ", a i =   p() ? " r ight-start" : "left-st a rt", li = { autoClose: !0, boundary: "cli ppingParents", display: "d yn a mic", offset: [ 0, 2 ], p o pper C onfig: nu l l, reference: "t og gle" }, ci = { autoCl ose:  "(boolean|string)", bo undary: "(string | ele m ent)", displa y :  "string", offset :  "(arra y |string|function)", popperConf ig: "(null| o bject|function)", refer ence: "(string|element| ob ject)" }; class hi exten ds z { constr u c t or(t, e) { super(t,  e ), this._popper = nu l l, this._parent = th i s._element.parent N o de, this. _ me nu = Q.next(this._ element , ei)[0 ]  || Q.prev(this._el ement, ei)[0] || Q.findOne(ei, this ._paren t),  th is . _inNavbar = this._detectNavba r()  } static get Def a ul t () { return li } sta t ic g et DefaultType() {  return ci } static get N A M E() { re t urn Qe } toggle( )  {  return thi s. _ i sShown() ?  th is.hide() :  this .s ho w ( ) } show()  { if (l(t his._element ) || this ._ isShown()) return;   const t = { re l atedTarg et: this._el e ment }; if (!P.trig ger(this._elem e nt,  "show.bs.dropdown", t).d e faul t Prevented) { if (thi s ._createP o pper(), "ontouchstart" i n  document . documentElement & &  !this ._parent.cl o sest(".nav b ar-nav")) for  (c onst t of [].concat(... do cument.body.children)) P.on(t, "m ouseover", h);  this ._element.focu s(), this._element.setA tt ri bute("aria-expanded", !0) , this._menu.c lassList.add(Je), this._ele me nt .classList.add(Je), P.tri gger(this._ele m ent ,  "shown.bs.d r opdown", t) }  }  hide() { if (l( t his ._element) || ! this . _isShown()) retur n ; con s t t = { rela t e d Target: this. _e lement };  th is._comp le teHide(t ) }   di spose() { this._poppe r && th is._pop p er.destroy(), super.dis p ose () } upd a te() { th i s._inNavbar = this._detec tNa vb a r(), this. _ popper &&  t his._popper. u pdate() } _comple t eHide (t)  { if  ( !P.trigger(this._element,  " hide.bs.dr o pd o wn", t).de f a ultPreve n ted) { if ("ontouc hs t art" in document .d o cumentElement )  f or (con st   t of [].concat( .. . d ocument.b ody .child ren )) P.off( t,  " mo u s eover", h ); this._popper &&  this._ popper.des troy(), t his._menu .c lassList.remove(Je ) , this._elemen t. c lassList .re move(Je), th i s._element.setAttribute("a ria-expanded",  "false"), B.re m oveDataAttribute(this._menu , "popper"), P. t rigger(this._element, "hidde n.bs.dropdown " , t ) } } _getConfig(t) {   if  ("object" == ty p eof (t  = super._getConfig(t)).re f erence && !o(t.refer e nce) && " f unction" != typeof t.ref e rence.get B oundingClientRect )  throw  new Ty p eError(`$ { Qe.toUpperCase()}: O p tion "refer e nce" provide d  type " o bject" withou t  a required "getBoundi ng ClientRect" method.`); r etu r n t } _createP o pper() { if (void 0  = == Ke) throw n e w T ypeError("Bootstrap's   dro pdowns require Popper ( https://popper.js.org)"); let t  = this._element; "par ent" === this._config.r ef erence ? t = this._pare n t : o( t his._config.r ef erence) ? t = r(this._ co nfig.reference) : "object " == typeof this._config.referenc e  && (t = this._ c onf ig.reference); const  e  =  this._getPopperConfig(); this ._popper = Ve(t, this._menu, e) } _ isShown() { return this ._ menu.classList.cont ains(Je) } _ge tPlacement() { const  t  = this._ p are nt; if (t.c lassList .contains("dro pend"))  return ri; if  (t.classList.contains("d ropstart")) return ai; if (t. classList.conta i ns("dropup-cen t er")) return "top";  i f (t.classList.contai n s("dropdown-cen ter")) ret urn "bottom"; const e = "end" = == getCompu tedStyle(this._men u) . getPropertyValue("--bs - position").trim (); return t .classList.co nt a ins("dropup") ?   e ? ni : ii : e ? oi : si } _detectNa vb ar() { return null !== this._element .closest(".navbar") } _getO f fset() {  const { offset: t } = this._config; return " string" == typeof t ? t.split(",").map(( t =>  Number.parseInt(t, 10))) : "funct ion" == ty peof t ? e => t(e, this . _e lement)   : t } _getPopperConfig()  { const t = {   pl acement: thi s ._g etPlacement(), mo difiers: [{ name: "preventOverfl ow", options: { boundar y:   this._config.bound ar y } }, { name: "offset", op tions: { offset: this . _ge tOffset() } }] }; return  (this._inNavbar  | | "static" ===   th is. _config.displ ay) && (B.setDataAt t ribute(this._menu, " p opper", "static"),  t.modifiers = [{ name: "app ly St y le s", enabl ed:  !1 }] ), { ...t, ..."function" ==  t ypeof this._config.p opperConfig ? thi s ._config.popperConfig(t) : this._confi g.po pperConfig }  } _selectMenuItem ({  ke y : t, target:  e  }) { const i = Q.find( ". dropdown-menu .dropd own- item:not(.disabled) :not(:disabled)", this._menu) .f il t er((t => a(t))); i.l ength && b(i, e, t === Ye ,  !i . includes(e)). foc us() } s ta tic jQueryInt erf ace(t) {  r eturn thi s.e ach((function () { co n st e = hi.getOrCreate In stance(this ,  t); if ("string" == typeof t) { i f ( voi d  0 === e[t])   throw new TypeError(`No met h od name d "${t}"`); e[t]() } })) } static clearMe nus( t) { if (2 === t.button || "keyup" === t.typ e && "Tab" !== t.key) return; const e  = Q.find(ti); for (co n st  i of e) { const e = hi. ge t Instance(i); if (!e || !1 === e._co nfig.autoClose) continue;  const n = t.composedPat h(), s = n.includes(e._m enu );  i f (n.includes ( e._element) || "inside" === e._config.autoClose   && !s || "outside" === e._co n fi g.autoClose && s) continu e; if (e._menu.contains(t.target) && ("keyu p" ===  t.type  & & "Tab" === t.key || /inpu t |select|option|textarea|form/i.test(t. t a rget.tagName))) continue; cons t o = {  rel a te dTarget: e._element }; "click" === t .t yp e  && (o.clickEvent = t), e._comp l eteHide(o)  } } static dataApiKeydownHandle r(t) { const e = /input |t e xtarea/i.test(t.target.tagName), i  = "Escape" === t.key, n  =   [Xe, Ye].includes(t.key); if  ( ! n & & !i) return;  if  (e && !i) ret urn; t.preventDefault( ) ; const s = thi s .matche s (Ze) ? this : Q.prev(this,   Ze)[0] || Q.next(this, Ze)[0] || Q.fin d O ne(Ze, t.delegateTarget.par e n t N od e) ,  o  = h i .getOrC r eat e Instance(s);  i f (n) return t. stopPropagation(), o.s h ow(), vo i d  o._ se le c tMenuIt e m(t ) ; o._isShown()   && (t.stopProp agation(), o.hide(), s . focus())   }  } P.on(document, G e , Ze, hi.dataApiKeydownHandler) ,  P. on(document, Ge, ei, hi.dataApiK e yd o wnHandler), P.on(document ,  U e, hi.clearMenus), P.on(do cu m ent, "k e yup.bs.dropdown.data-api", h i.c le arMenus),  P .on(docum e nt , Ue, Z e,  (func tion (t) { t.preventDefault(), hi.getOrCreateI nstance ( thi s ) .toggle() })),  g(hi); const di = ".fixed -top, .fixed-bottom, .is-fi xed, .sti cky - top", u i  = ".sticky-t op", fi = "padding-right", pi  =  "margin-right"; cla ss gi {  con st ru c tor() { this._elem en t = docu men t.b od y  } getW id th() { const  t  = do cument. d ocumentElement.clientWidt h ;  return Math.abs(window.in nerWidth - t) } hide() { const t = thi s.ge tWidth (); th is._disa b leOverF lo w (), this._ se t ElementAt tr i butes(this._elemen t,   fi, (e => e + t)), this._setE le m entAttributes(di, fi,  (e   = > e + t)) , t his._setE lem entAttr ib ut es ( u i, pi, (e  => e - t)) } reset () { this ._resetEle mentAtt ributes(t hi s._element, "overf l ow"), this._re se t ElementA ttr ibutes(this._ e lem ent, fi), this . _resetElementAttributes(di,  fi), this._res e tElementAttributes(ui, pi) }  isOverflowing() { return   this.getWidth() > 0  }  _disable O verFlow() { this._saveIn i tialAttri b ute(this._element ,  "over flow"), thi s ._element . style.overflow = "hi d den" } _set E lementAttrib u tes(t,  e , i) { const  n  = this.getWidth(); this. _applyManipulationCa l lback(t, (t =>   { if (t !== this._e le ment && window . inn erWidth > t.clientWidt h + n) return; this ._ saveInitialAttri bute(t, e); const s = window.getComputed Styl e(t).getPropertyValue(e); t.style. setPropert y(e, `${i(Number.parseFloat(s))} px`) })) } _saveInitial At t ribute(t, e) { cons t  i = t.style.getPropert yV alue(e); i && B.setDataAttr ibute(t, e, i) } _resetElementAt tributes(t, e) { this._applyManipul ationCallback(t, (t => {  const i = B.getDataA t tribute(t, e);   nu ll  !== i ? (B.rem oveD a taAttr i bute(t, e), t .s tyle.setProperty(e, i)) :  t.style.removeProperty(e) })) } _app ly ManipulationCallback(t, e) { i f (o(t)) e(t); else f or (const i o f  Q. find(t, this._element)) e(i) } }  const mi = "show", _i  = "mousedown.bs.backdr op " , bi = { className: "modal-backdro p",  clickCallback: null, isAnimated: !1, isVisib le: !0, rootElement: "body" }, vi = {  className: "string" ,  clickCallback: "( function|null)", isAnima ted : " boolean", isVi sible :  "boolean " , rootElement: "(element| string)" }; class yi extends  F { constructor ( t) { super(), this._c o nfig =  t his._getConfig(t), this._isAppe nded = !1, this ._element  = null } static get D efault() {  r eturn bi }  sta tic get Defa ultType() { return vi } s tatic get NAME ( )  {  r e turn "ba ckd rop" } show(t) { if ( ! this._confi g .isVisible) return void  m(t ) ;  thi s. _ append(); const e = th i s._getElement() ; this._conf ig.isAnimated  & &  d(e), e.classList.a d d(mi), this._emulat eAnimation((() => { m(t) })) }  hi de ( t) { thi s._ confi g. isVisible ? (this._get E lement().cl a ssList.remove(mi), this. _emu lat e Animation((() => { this.d i spose(), m(t) }))) : m(t)  }  d ispose( )  { this._isAppended && (P.of f(t hi s._elemen t,  _i), thi s ._ element .re move () , this._isAppende d  = !1) } _getE lem en t() { if (!this._element) { const t = document .createEle m ent ( " div"); t.class Name = this._config.className,  this._config.isAnimated && t.c lassList. add ( "fade") ,  this._e le ment =  t } return this._element } _c on figAfterMerge(t) {  return t .rootEl ement =  r(t .ro ot E lement) ,  t } _append( ) {  if (thi s ._isAppended)  r et u rn;   co nst t = this._getElement( ); this._config.rootElement.append(t),  P.o n(t, _i, (()  => { m(this._config.clickCal lba ck )  }) ), this._isAppended = ! 0 } _emulateAnimation(t) { _(t,  this ._getElement (), this._config.isAni mat ed )  }  } const wi = ".bs.focustrap", Ai = "backward", Ei = { autofocus: !0 , trapE lem ent: null }, Ti = { autofocu s:  "boolean", trapElement: "elemen t" } ; clas s Ci e xtends F   { constructor(t) { sup er(), t his._co nfig = this ._getConfig (t), this ._isAc tive = !1, this ._ l astTabNavDirection = null } static get Default() { return Ei } st at i c get DefaultType() { return Ti } static get NAME() { return "focustrap" } activate() { this._isActive || (this._config.autofocus &&  th i s._ co nf i g.trapE l ement.focus(), P.off(docu ment, wi), P.on(docu m ent, "focu si n.bs.focustrap", (t => this. _h andleFocusin(t))), P. o n(document,  " keydown.tab.bs.focustrap", (t  = > this._han dl eK e y down (t))), th is._is Activ e = !0)  } deac tivate() { this._i sA ctive && ( this._i sActive  = !1, P .off( doc um ent , w i))  } _ han dleFo cus in(t ) {  co nst  {  tra pEl eme nt:  e  } =  th is. _co nfi g;  if  (t. ta rge t == = docum ent || t. target  === e | | e.cont ains(t.tar get ))  ret urn ;  con st i  =  Q. foc usable Chi ldren (e) ; 0  ===  i.l eng th ? e. foc us ()  : t hi s. _l a s tTabNavDir ect ion ===  Ai  ? i[i.lengt h -  1].f ocu s() : i[0 ].f ocus() } _h andle Keydown(t ) { "Tab" ===  t .k e y  && (this. _lastTabN avDirect ion = t.s hiftKey ? A i : "forward") } } c onst  Oi = "hidd en.bs.mod al", xi =  "show.bs.mo dal", ki = "modal- open", Li  = "show ",  D i   = "mod al-static", Si = { backdrop: !0,  focus: !0 , keyboard: !0 },  Ii  = { backdrop: "(b o olean|string)" ,  focus:  "boolean", k e yboard: "boolean"  } ; class Ni extends z   { constru c tor(t, e) { super(t, e),   this._dia l og = Q.findOne(". m odal-d ialog", this._ele m ent), this._ b ackdrop = this._initializeBackDrop(), this._focus tr ap = this._initializeFocusTrap(), this._isShown =  ! 1, this._isT r ansitioning = !1, this._scrollB a r   = new gi, this._ a ddEventListeners() } static g et Default() { retur n   Si } static get DefaultT ype( )  { re t urn Ii }   static  g et NAME() { return "modal" } t oggle(t) {  r eturn this._isShown ? this.hide() : this.sh ow( t) } s how (t ) { this._isShown || this._isTransitioni ng || P.trigger(thi s. _el ement,  x i, { relatedTa r g et: t }).defaultPrevented || (this._isShown = !0, this. _isTrans it ioning = !0, this._scrollBar.hide ( ) , document.body.cla s sList.add(ki), this._adjus tDialog(), this._backdrop.sho w ((() => this._sh o wEl ement( t)) ))  } hide() { this._isS hown && !this._isTransit ioning &&  ( P.trig g er (th i s._element, "h id e. b s.modal " ).defaultPre ven t ed  ||   (this._isShown = !1, this._isTran s itio n ing = !0, this._focustrap.deacti va t e(), this._elemen t .classList. r emove(Li), this._queue C allback((() = >   t his._hideMo d al()), this._elem e nt, this._isAnimated()))) }  d ispose()  {  fo r  ( co nst t of [w indow, th is ._ di alog]) P.o ff (t, ".bs. modal"); thi s._back d rop.dispose(), this._focustrap.deactivate (), super.dis p o se() } handleUpdate() { this._adjustDialog( ) }  _initializeBa c kDrop()   { return new yi({ isVisib le : Boolean(this._config.backdr o p), isAnima ted: thi s ._isAni m ated() }) } _initializeFocu s T rap() { return n ew  Ci ({ t ra pEle men t: this._eleme nt })  }  _ showElement(t) { document.bod y .contains(this._element ) ||  document.body.append(t his._element), this._ele m e n t.style.display = "block",  t his._e lement.rem ov eAttribu t e("aria - h i dden"), this._element.se tA t tr ibute("aria-modal",  !0), this._elemen t .se tAttribute("role" , "dialog"),  t his._element. s c rollTop  =  0; const e = Q.find One(".modal- body", this._di al o g); e & &  ( e.scrol lT o p = 0), d (t h is._element), th is . _element .c l assList. ad d ( Li),  this._q ueue Callba ck((()  =>   { this . _config. focus & & this._f ocust rap . activat e (), th is ._ i s Transition ing  = !1, P.t rig ger(this. _element, "shown.b s.modal",  { r elatedTarget : t  }) }) ,  this._dialog, this. _isAnim ated())  } _addEve ntListen ers()  {  P.on(th is. _el ement, "ke ydown. dismiss.bs.mo dal",  (t => {  if  ("Escape" = == t. key) retu rn  this._con fig.keyboard ? (t.preventDefault(), void this.hide()) : void this._triggerBackdropTransition() })), P.on(window , "res ize .bs.moda l", (() => {  th is . _ isShown &&  !this._i sTransitio ning && th is._adjus tDialog() })), P.on (this._ele ment, "mousedown.dismiss.bs .modal", (t  => { P.one(this._ele ment,  "click.dismiss.bs. modal", (e => { thi s._eleme nt == = t.target  && thi s._element === e.target &&  ("static"  !== this._config.ba ckdrop ? this ._config.backdrop && this .hide() :  this._tri ggerBackdro pTransition()) }))  })) } _h ideModal() { this._ element.s tyle.disp lay =  "none", this._element.setAtt ribute(" aria-hid de n", !0), this._ele m ent.removeAttr ib u te ("aria- mod al" ), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdro p.hide(( ()  => { document.b o dy. classList.rem o ve (ki), this._res e tAdju stments(), this._sc r oll Bar.reset(),   P.tri gger(this._element, O i ) }))  } _isAnimated()   { ret urn this . _elem ent.classList.contain s("fade") } _triggerB ac kdropTransition( )  { if (P.trigger(thi s ._element ,  "hidePrevented.bs.modal " ).default P revented) return;   const  t = this. _ element. s crollHeight > d o cu m ent.docum e ntElement.clien t He i ght, e = this._ e lement.style.ov e rflowY; "hidden"   === e ||   this._element.c la ssList.contains(Di) || (t  | | (this._element.style.over flowY = "hidden " ), this._elem e nt.classList.a d d(Di), th i s._queueCallback((() => { th is._element.classList.remove(Di) , t his._queueCallback((() = > { this._element.style.overflowY = e }), this._dial og ) }), this._dialog), this._element. focus()) } _adjustDialog() { const t = this._element.s crollHeight > document .documentElemen t .clien t He ight, e  =  this._scrollBar.getWidth(),  i = e > 0; if (i && !t) { const t = p() ? "paddingLeft"  :  "paddingRight"; this._ el ement.style[t] =  `${e}px ` } if  ( !i && t) { const t = p()  ? "paddingRight" : "paddingLeft"; t h i s._element.style[ t]  = `${e}px` } } _resetAdjustments() { this._element.style.paddingLeft  =  "", this._element. st yle .paddin gRight = "" } static j QueryIn t erface(t, e) { return  this.each((function () { const i = Ni.getOrCre ateInstance(this, t);  if (" s tring" ==  t y p eof t) { if ( vo id 0 === i[t]) throw new TypeError(`No method named "${t}"`); i [t ](e) } })) }  } P.on(document, "click. bs.modal.data-api", '[data-bs-toggle="mod al"]', (func t ion (t) { const e = n( this);["A", "AREA"]. includes(this. tagName) && t.preventDefault (),  P.one(e, x i, (t => { t.defaultPrevented || P.on e(e, Oi , (() => { a (th is) && this.focus() }))  } ) ); const i = Q.findOne(" .modal.show"); i && Ni.getInstance(i) .h ide (), Ni.getOrCre at eInstance(e).t oggle(this) })) ,  q (Ni ), g(Ni);  const Pi = "show",   ji = " s ho wing", Mi = "hid in g", Hi = ".offcanvas.show ", $i = "hidePrevented.bs.offcanvas", Wi = "hidden.bs . of fcanvas", Bi = { backdrop: !0, keyboard: !0,  scroll: !1 },  Fi = { backdrop: "(boolean| str ing)", keyb oard: "boolean", scroll: "boolean" };  class z i extends z  { c onstructor(t, e) { super( t , e ), this._isShown = !1, th i s._ backdrop = this._initiali z eBa ckDrop(), this. _ focus trap = this._initialize Fo c usTrap(), this._addEventLis te ners() } static  ge t Default() { return B i } static get DefaultType() { return Fi } static  get NAME() { return "off canvas" } toggle(t) { return this._isS how n ? this. hide() : this.show( t )  } show( t ) { this._is Sh own || P.trigger(this . _element, "show. b s.offcanvas", { relatedTarget: t   }).defaultPreven t ed || (this._is Sh own = !0,   this._backdrop.show(), this._config.scr ol l || (new gi).hide(), this._elem ent.setA t tribute("aria-modal" ,  !0), t h is._element.setAttribute("role", "dia lo g"),  this._eleme nt.classList.add(ji),  this ._queueCallback((() => { this._config.scroll && !thi s._conf i g. ba c kd r o p  || this._focus t rap.activate() ,  this ._element.classList.add(Pi),  this._el ement.classList.remove(ji), P.trigger (this._element, "shown.bs.o ffc anvas", { relatedT ar get: t }) }), this._ e l ement, !0)) }   hide() { this._i s Sh own && (P.trigg er (this._element, "hide.b s.offcanvas" ) .defaultPrevented || ( t his._focustrap.deactivate(),   this._element.blur(), this._isShown =  ! 1, this._element.clas s List.add (Mi), this._back drop.hid e( ), this._qu eueCallback((() => { this._element.classList.remove(Pi,  Mi ), this._element.remo v eAttribute("aria-modal") ,  this. _ element.removeAtt ribute("role"),  t h is._config. s croll || (new gi).reset(), P.trigger(this._element, Wi)  }) , this._element, !0))) } dispose() { this._backdrop. d ispose(), this._focustrap.deact i vate(), super.dispose() } _initializeBackDrop() { const t = B oolean(this._config.backdr o p); return ne w  yi({ className: "offcanvas-b ac kdrop",  is Visible: t, isAnimated: !0, roo t Element: t h is._element.par en tNode, clickCallback: t ? () =>   { "static" !== t h is._con f ig.backdro p  ? this.hide() : P.trigger(thi s ._element, $i) } : null }) } _ini ti alizeFocusTrap ( ) { return new Ci({ tra p E lement: this._elemen t }) } _addEventListener s( ) { P.on(this._element, " k eydown.dismi s s.bs. o ffcanva s " ,  (t => { "Esc ape" = == t.key  & & (this. _ config.keyboard ? t hi s.hide() : P.trigg er(th i s._element ,  $i)) }))   }  s tati c jQueryInterf a c e (t) { return this.each((fun c tion ( ) { const  e  = zi.get O rCreateInstance(this,   t ) ; if ("string" == t y peof t)   {  if (void  0  === e[t] | |  t.sta rtsWith ("_") ||   "constructor" === t ) throw new TypeError(`No metho d  n a med " ${t}"`);  e[t](thi s ) } }))  } } P.on(documen t ,  " click .bs.offcanvas.data -api", ' [ data-bs-t oggle="offcanvas"]',  ( fu n ction  (t) { c onst e =   n(this);  if (["A", "AREA"].includes(this. t ag N ame)  && t.preventDefaul t(), l(t his )) ret urn; P.one(e,  Wi ,  ( ( ) => { a(this) && this.focus() })); const i = Q.findOne(Hi) ; i && i !== e &&  z i. ge tInsta n ce(i) .hide(), zi.g et OrCreateInstance(e).toggle(this)   })), P.on(window, "load.bs.o f fcanvas.data-api", (() =>   {  for (const t o f  Q.find ( Hi)) zi.getOrCreateInstance(t).s how () })), P.on(w in dow, "re siz e. bs.offcanvas", (()  => { for (const t of Q.find("[aria-m odal][class*=show][cla ss *= o ffcanvas-]")) "fixed" !== getComputedStyle(t) .pos ition & & zi.getO rCr ea t eInstan c e (t) .h i de() })), q(zi), g(zi); const qi = new S e t(["background", "cite", "href", "item t y p e",  " l ongdesc", "poster", "src", "xlink:href"] ) , Ri = /^(?:(?:https?|mailto|ftp|tel|fi le|sms):|[^#&/:?]*( ?: [#/?]|$))/i, Vi = /^da ta :( ? :image\ / (?:bmp|gif|jpeg|jpg|png|tiff|webp)|vi deo\/(?:mpeg|mp4|ogg|webm) |au dio\/( ? :m p 3|o g a|o gg|opus)); base 64,[\d+/a-z]+=*$/i,  K i = (t, e) => { const  i  =  t .nodeNa m e.toLowerCase(); return e.includes(i)  ? !qi.has(i) || Boolean(Ri .te st(t.n o de V alu e ) || Vi.test(t.nodeValue)) : e.filter ((t => t i nst a nceof RegExp)).some((t   =>  t . test(i))) },  Qi  = { "*": [ "c lass", "dir", "id", "lang", "ro le" , /^aria-[\w-]*$/i], a:   ["target",  " href",  " title", "rel"], area: [], b: [], br:   [] , col: [], code: [], div: [], em: [], hr:  [ ], h1: [], h2: [], h3: [], h4: [ ],  h5: [], h6: [], i: [], img: ["src", "sr cse t", "alt", "title", "width", "height"], li: [], ol:  [],  p: [], pre: [], s: [], small: [], span :  [], sub :  [], sup: [], s tr ong: [], u: [],   ul: [] }, Xi =  {  a l lowList: Qi, con t ent : {}, extraClass: "" ,  h tml: !1, saniti ze : !0, sanit ize Fn: null, template: "<div > </div>"  } , Yi = { allowList: "object ",  content: "objec t ",  extraClass: "(string |f u nction)", html:  " boolean", s ani tize: "boolean", sanitize F n: "(null|func ti o n)", template: "string" }, U i = { entry:  " (string|eleme nt | function|null)", selec t or: "(string|element)" }; class Gi extends F { constru c tor(t) { supe r (), thi s ._config = this._getConfig(t) } sta tic  get Default() { return Xi  } static  ge t DefaultTyp e() { re t u rn Yi  } static g et  NAME()  {  r e t u rn  " T e mplateFactory" } getCont e n t() { return Object.values (this._config.content).ma p ( (t => this._resolveP o ssibleFunction(t)) ) .f ilt er(Boolean)   } hasContent( )  { return this. getConte nt ().length > 0  }  changeCo n t ent(t ) { retu rn th is._che ckC ontent(t ),  this._config. co ntent =  {  ...this._config.con tent, .. .t  }, this } toHtm l( ) { const  t  = document.createElem e n t("div"); t.innerHTM L  = this . _ma ybe Sanitize(this._config.tem plate); for (const [e, i] o f O bject.entries(t hi s._co n fig.content)) thi s._setContent(t,  i , e ); const  e  = t.chil d r en[0], i = this. _ resolvePossi bl eFunction(this._config.e xtraClass);  r eturn  i && e.c la ssList.add(...i.spl it(" ")) ,  e }  _ typeCheckConfig(t) { supe r ._typeCheckConfig(t), this ._ c heckCon t ent(t.content) } _checkConte nt( t)  { for (c on st [e, i]   of  Object .en tries (t)) super._typeCheckConfig({ selector: e, ent ry: i  } , U i )  } _se tContent ( t , e, i) { cons t n = Q. fin dOne(i,  t) ; n  && ((e =  this._re solvePoss ibleFunction(e)) ? o(e) ? this._putElementInTemplate(r(e), n) : this._config.html ? n.innerHTML = this._maybeSanitize(e) : n.textContent = e :  n.remov e()) }  _m ay b e Sanitize(t) { retu rn this. _config.sanitize ? function (t,  e,  i) { if (!t.length )  return t; if (i &&  " function"   == typeof i) return i(t) ;  const n  =  (new window.DOMP a rser). parseFrom S tring(t, "text/h t ml"), s = [].concat(... n. body.querySelector A ll("*")); for (const t o f  s) {  c onst i = t.nodeNam e.toLowerCase();  if (!Object.keys (e).includes(i)) {   t .remove(); co n tinue } const n = [].concat(...t.attributes), s = [].conca t (e["*"] || [], e[i] || [] ) ; for (const e of n) Ki(e,  s )  || t.r e moveAttribute(e.nodeName) }  ret ur n n.body. in nerHTML } ( t,  this._ con fig.a llowList, this._config.sanitizeFn) : t } _reso lvePos s ibl e F unctio n(t) { r e turn "function" == ty pe o f t ? t(t hi s ) : t } _ pu t E lementI nTemp late(t, e)  { if (this._con fig.html) ret urn  e.inne rHTML  = "", voi d e. app en d( t) ;   e.textC ontent = t.textC ontent } }  const Ji  = new Set(["s anitize",  "allowL ist", "san itizeFn"]) , Zi =  "f ade", tn = "show",   en = ".modal",  n n  = "hide .bs .modal", sn = "ho v er", on  = "focus", rn = { AUTO:  " auto", T OP: "top", RIGHT:   p() ? "le ft"  : "right", BOTTOM: "bottom", LEFT: p() ?   "rig h t" : "left" },  an = { allowList:   Qi, a nimation: !0,  b ounda ry: "clippingParents", c o n tainer: !1, cust om Class: "", delay :  0 , fallbackPlac e ments: ["top", "righ t ", "botto m ", "left"], html: !1, of f set: [0,  0 ], placement: "to p ", pop perConfig:  n ull, sani t ize: !0, sanitizeFn: null, selector: !1,  template: '<div class="tooltip"  role="tooltip " ><div class="tooltip-arrow" > </div><div cla s s="tooltip-inner"></div ></ div>', title: "", trigger: "hover focus" }, ln  = { allowList: "object",   animation :  "boolean", boundary: "(stri ng|element)", c o ntainer: "(string|el e ment|boolean)",   customClass :  "(string|funct ion)", delay :  "(numbe r |object)", fallbackPlace m ents: "array" , html:  "b oolean", offset: " (a rray|string| f unction)", placement: "(strin g| function)", popperConfig :   "(null|object|function)",  s anitize: "boolean", sanit iz eFn: "(null|function)", sel ecto r: "(string|boolean)", te mpl ate :  "s t ring",  t itle: "(string|element|function)", trigger:  "s tri n g" }; class cn exte nds z {   constructor(t, e)  {  if (vo i d  0 === Ke)  t hrow new TypeError("Boot st rap's toolti ps require Popper (https ://p op per.js.or g)"); su per (t, e), thi s . _ isEn a bled = !0, this._ t imeout  =   0, th is._isHovered = nu ll, this._ activeTrigger = {}, thi s._popper =  null, this._templateFa ct ory = null, this._newContent = nul l,  this.tip = null, this._set Li s teners(), this._conf i g.selec t o r  || this._fixTitle() } static get Default( )   {  r e turn an } static get DefaultType() { ret u rn ln } static get  NAME() { return "to ol t i p" } enable() { th is ._isEnabled = !0 } disable() { this. _ i s En abled = !1 } toggleEnabled() { this._isEn abled = !this._isEnabled } toggle() { th i s. _is Enabled && (th i s. _activeTrigger.clic k  = !this._activeTr i gger. click, this._isShown() ? this ._leave( )  : this . _enter()) } dispos e( ) { clearTimeout(this._timeout), P.off(th is ._ el em e nt .close st( en), n n , this ._ h id eMod a l Handler), this._element.getAttribu t e("data-bs-origin a l-title" ) && this._element.setAt t ribute(" title",   this._elem ent.getAttribute("dat a-b s-original-tit l e" )), this ._ dispo sePopper( ), supe r .dispose() } show () { if ("none"  ===  t his._element.style.display) th row  new Error("Please use show on visib le  e l ements"); i f  (!this._isWithCon ten t ()  || !this._isEnabled) return; const t = P.tri gger(this._element ,  t his.constructor.even tName("show")), e = (c(th is._element) || this._el ement.ownerDocument.docu m entElement).co n tai n s(this._element); i f  ( t.defaultPrevented || !e) return; this. _disposePopper(); const i = t his._getTipElement(); this._element.setAtt ribute(" aria-describedby", i.get Attribute("id")); con st  { container: n } = th is._config; if (this._element.ownerDocument.documentEl ement.contains(this . tip) || (n.append(i) ,  P.trigger(this._elemen t, this . constructor.eventName(" ins ert ed"))), this._ popper = this._createP o pper(i), i.classList.add( t n), "ontouchstart" in docu me n t.docum e ntElement) for (const t of [ ].c on cat(...do cu ment.body . ch ildren) ) P .on( t,  "mouseover", h);  t his._queueCal lba ck ((() => { P.trigger(this._element, this.constr uctor. e ven t N ame("shown") ), !1 === this._isHovered &&  thi s. _ lea ve(), this._isHovered = !1 }), this.tip, this ._isAnimated()) } hide()  { if  (this ._isShow n () && !P.tri gg e r(this._eleme nt ,  this.cons tr u ctor.eventNa me ( "hide")). de f aultPre ve n ted) {  if   (this._getTipElement().classList.remove(tn), "ontouchstart" in document.doc um e ntElement) for (const t of [].concat(...document.body.children)) P.off(t, "mouseover", h); this._activeTrigger.click  = !1, this._active T rigger.focus =   !1, this. _activeTrigg e r.hover = !1, this._isHovered = null, this._queueCallback((()  => { this._ is WithActiveTrigger() || (this._isHovered | | this._disposePopper (), this._element.r emoveAttribute("a ri a- describedby"), P.tr i gger(this._elemen t , this .cons t ructor . eventNa m e("hidden")))  }) , this.tip, this._isAni mated() ) } } u p date() { this._popper  & &   t his._popper. update() } _is W ithContent() {   re t urn B oolean(this. _getTitle()) }   _getTipElement ( ) { return this.tip  | |  ( this.tip = this._c re ateTipElement(this._ new Content || this._ get C ontentForTem pl a t e( ))), this.tip } _crea teTipElement(t) { con st e = this._getTemplat eF a ctory (t) .toHtml(); if (!e) ret u rn null; e.classList.remove(Zi,  tn), e.classList.add(`bs-${thi s.co nstructor.NAME}-auto`);  con st i = (t =>  { do { t += Ma t h.floor(1e6 *  M ath . random()) } while ( doc um ent.getElementById(t)); re t urn t })(this. co n s tr uctor.NAME).toString();  return e. setAttribute("id", i),  this._isAnimated() && e .c l assLi st. add(Zi), e } setConten t (t) { this._newContent = t, this ._is Shown() && (this._disposeP opper( ), this.show()) } _getT empl ateFactory(t ) { return this. _ templateFactor y  ?  t his._templateFactory.c han ge Content(t) : this._templat e Factory = n e w  Gi({ . ..t his ._config, content: t , extra Class: this._resolve PossibleFunction(th is._con f ig.c ustomClass) }), this . _ templateFactory } _getContentFo rT emplate( ) { retur n  { ". t oo ltip-inner ": this._getTi tl e()  } } _getTitle() { return this._r e solvePossibleF u nction(this._conf ig.title) ||  t his._element.get A ttribute("data-bs-original-title")  }  _initializeOnDelegated Ta rget ( t) { return this.constru ct o r.getOrCreateInstance(t.delegate Target,  this._getD ele gateConfig())  } _isAnimated() { return this._confi g .animation || this.tip && this. t i p .classList.contains(Zi) }  _isSho w n() { return this.tip  & &  this.tip.classList.conta ins(tn) } _createPopper(t) { co nst   e =   "f unction" == typeof this._config. placeme nt ? this._confi g .p lacement.call(this, t, thi s._ele ment) : this._config.placement,  i = rn[ e.toUpp erCase()]; return Ve(this._element, t, thi s ._getPopperConfig(i)) } _getOffset()  {  const  {  offs e t:  t } = this._config; return "stri ng" ==  typeof t ? t .spl it (",").map((t => Number.parseInt( t, 10))) : "functi on" == typeo f  t ? e => t(e, thi s. _ element )  : t } _resolvePossibleFu nc tion(t) { return "function" == type of t ?  t.call( t his ._ el e ment) :   t } _getPopp erC o nf ig(t) { const e = { p la ce ment: t, modifiers: [ { na me: "flip", options : {  fallbackPlacements: this._confi g. f allbackPlacements } }, { na me :  " offset", options:  {  offset: this._ge tO f fset() } }, { na m e: "preventOverflow", options:  {  boundary: this._co n fig.boundary } }, {  n a m e: "arrow", o pt i ons: { element: `.$ { this.constructor.NAME}-arrow` } }, { name: "pre Se t P lacement", enabled: !0, p h ase: "beforeMain", fn: t = >  {  this._ g etTipElement().setAttribute(" da ta-popper -p lacement" ,  t .state. pla ceme nt ) } }] }; return  {  ...e, ..."fun cti on " == typeof this._config.popperConfig ? this._ config . pop p e rConfig(e) : t his._config.pop per Config }  } _ s etLis teners() { const t = this._con fi g.trigger.split(" " ); for  (c onst e of t) if ("click" === e) P.o n(th is._element,  this.construc tor .e v ent Name("click"), this._config.selector, (t => { this._initializeOnDelegatedTarget(t).toggle() })); else if ("manual" ! == e) { const t = e === s n ?  this.c onstruct o r.event Na m e("mous ee n ter") : th is . c onstructor .eventName ("focusin "), i = e  === sn  ? this. co ns t r uctor.even tNa me("mouse lea ve") :  th is .constructor.event N ame("focusout" );   P.on(thi s._ element, t, t h is._c onfig.selector, (t => { c o nst  e = this._initializeOnDeleg a ted Target(t); e._active T rigger["focusin" ===   t.type ?  o n : sn] = !0, e._enter()   })), P.on ( this._element, i,   this._ config. s electo r , (t => { const e = this ._initializeOnDelegatedTarget(t);  e ._activeTrigger["focus out" === t.type ? on :  s n] = e._element.contains(t.relatedTa rget), e._leave() })) } this._hideM odalHandler = ()  => { this._element && this.hide () } , P.on(this._element.cl os e st(en), nn, this._hideModalHandler)  } _fixTitle() { const t  = this._element.g etAttribute("title"); t & & ( this._element. getAttribute("aria-label " ) || t h is._element.te xt Content.trim() || this._e lement.setAttribute("aria-label",  t ), this._element.setAttribute("da ta-bs-original-title",  t) ,  this._element.removeAttribute(" title")) } _enter() { this._isShow n()  || this._isHovered ? thi s._isHovered = !0  : ( this._isHovere d = !0, this._setTimeout( ( () => { t h is._isHovered && this .show() }), th is ._config.delay.show)) } _leave() {  this._isWithAct i veTrigger ( ) || (this._isHovered = !1, this._setTimeou t ((() => { this._isHo v ered || this.hide() } ),  this._config.delay.hide))  }  _setTimeout(t, e) { clearTi me out(this._time o ut), this._tim eo u t = setTime out (t, e) } _isWithActiv e Trigger() { retur n  O bject. values(t h is._ activeTrigge r).i ncludes(!0)  } _getConfig(t) { const  e  =  B.get Data Attributes (thi s._element) ; for (const t of Object.key s ( e))  Ji .has(t) && delete e[t]; return t  = { ... e , ..."object" ==  typeof t &&  t ?   t  : {} }, t = this._mergeCo nf igObj(t), t = this._confi g AfterMerge(t),  t his._typeCheckConfi g(t), t } _configAfte rM er ge(t) { return t.conta iner =  !1 === t.container  ? document.body : r (t .c ontainer), "number" ==  typeo f t.delay && (t.del ay = { show: t.dela y,  h ide: t.delay }), "numb er" ==  typeof t.title &&  (t.title = t.title.t oS tr ing()), "number" == ty peof  t .content && (t. c ontent = t.content.toString( )), t } _getD e lega t eConfig() { const t = {};   for (const e in this._conf ig )  this.c o nstructor.Default[e] !== thi s._ co nfig[e] & &  (t[e] = t h is ._confi g[e ]); r eturn t.selector = !1, t.trigger = "manual", t  } _dispos e Pop p e r() { this._p opper  & & (thi s. _popper .d estroy(),  th is._poppe r =  null), t his .tip & & ( this.tip.r emo ve(), th is. tip = null ) }  sta tic  jQuer yIn terface( t)   { return this.each((function () { const e = cn.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } g(cn); const hn = { ...cn.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" }, dn = { ...cn.DefaultType, content: "(null|string|element|function)" }; class un extends cn { static get Default() { return hn } static get DefaultType() { return dn } static get NAME() { return "popover" } _isWithContent() { return this._getTitle() || this._getContent() } _getContentForTemplate() { return { ".popover-header": this._getTitle(), ".popover-body": this._getContent() } } _getContent() { return this._resolvePossibleFunction(this._config.content) } static jQueryInterface(t) { return this.each((function () { const e = un.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } g(un); const fn = "click.bs.scrollspy", pn = "active", gn = "[href]", mn = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null, threshold: [.1, .5, 1] }, _n = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element", threshold: "array" }; class bn extends z { constructor(t, e) { super(t, e), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh() } static get Default() { return mn } static get DefaultType() { return _n } static get NAME() { return "scrollspy" } refresh() { this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver(); for (const t of this._observableSections.values()) this._observer.observe(t) } dispose() { this._observer.disconnect(), super.dispose() } _configAfterMerge(t) { return t.target = r(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, "string" == typeof t.threshold && (t.threshold = t.threshold.split(",").map((t => Number.parseFloat(t)))), t } _maybeEnableSmoothScroll() { this._config.smoothScroll && (P.off(this._config.target, fn), P.on(this._config.target, fn, gn, (t => { const e = this._observableSections.get(t.target.hash); if (e) { t.preventDefault(); const i = this._rootElement || window, n = e.offsetTop - this._element.offsetTop; if (i.scrollTo) return void i.scrollTo({ top: n, behavior: "smooth" }); i.scrollTop = n } }))) } _getNewObserver() { const t = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin }; return new IntersectionObserver((t => this._observerCallback(t)), t) } _observerCallback(t) { const e = t => this._targetLinks.get(`#${t.target.id}`), i = t => { this._previousScrollData.visibleEntryTop = t.target.offsetTop, this._process(e(t)) }, n = (this._rootElement || document.documentElement).scrollTop, s = n >= this._previousScrollData.parentScrollTop; this._previousScrollData.parentScrollTop = n; for (const o of t) { if (!o.isIntersecting) { this._activeTarget = null, this._clearActiveClass(e(o)); continue } const t = o.target.offsetTop >= this._previousScrollData.visibleEntryTop; if (s && t) { if (i(o), !n) return } else s || t || i(o) } } _initializeTargetsAndObservables() { this._targetLinks = new Map, this._observableSections = new Map; const t = Q.find(gn, this._config.target); for (const e of t) { if (!e.hash || l(e)) continue; const t = Q.findOne(e.hash, this._element); a(t) && (this._targetLinks.set(e.hash, e), this._observableSections.set(e.hash, t)) } } _process(t) { this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(pn), this._activateParents(t), P.trigger(this._element, "activate.bs.scrollspy", { relatedTarget: t })) } _activateParents(t) { if (t.classList.contains("dropdown-item")) Q.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(pn); else for (const e of Q.parents(t, ".nav, .list-group")) for (const t of Q.prev(e, ".nav-link, .nav-item > .nav-link, .list-group-item")) t.classList.add(pn) } _clearActiveClass(t) { t.classList.remove(pn); const e = Q.find("[href].active", t); for (const t of e) t.classList.remove(pn) } static jQueryInterface(t) { return this.each((function () { const e = bn.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } P.on(window, "load.bs.scrollspy.data-api", (() => { for (const t of Q.find('[data-bs-spy="scroll"]')) bn.getOrCreateInstance(t) })), g(bn); const vn = "ArrowLeft", yn = "ArrowRight", wn = "ArrowUp", An = "ArrowDown", En = "active", Tn = "fade", Cn = "show", On = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', xn = `.nav-link:not(.dropdown-toggle), .list-group-item:not(.dropdown-toggle), [role="tab"]:not(.dropdown-toggle), ${On}`; class kn extends z { constructor(t) { super(t), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), P.on(this._element, "keydown.bs.tab", (t => this._keydown(t)))) } static get NAME() { return "tab" } show() { const t = this._element; if (this._elemIsActive(t)) return; const e = this._getActiveElem(), i = e ? P.trigger(e, "hide.bs.tab", { relatedTarget: t }) : null; P.trigger(t, "show.bs.tab", { relatedTarget: e }).defaultPrevented || i && i.defaultPrevented || (this._deactivate(e, t), this._activate(t, e)) } _activate(t, e) { t && (t.classList.add(En), this._activate(n(t)), this._queueCallback((() => { "tab" === t.getAttribute("role") ? (t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), P.trigger(t, "shown.bs.tab", { relatedTarget: e })) : t.classList.add(Cn) }), t, t.classList.contains(Tn))) } _deactivate(t, e) { t && (t.classList.remove(En), t.blur(), this._deactivate(n(t)), this._queueCallback((() => { "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), P.trigger(t, "hidden.bs.tab", { relatedTarget: e })) : t.classList.remove(Cn) }), t, t.classList.contains(Tn))) } _keydown(t) { if (![vn, yn, wn, An].includes(t.key)) return; t.stopPropagation(), t.preventDefault(); const e = [yn, An].includes(t.key), i = b(this._getChildren().filter((t => !l(t))), t.target, e, !0); i && (i.focus({ preventScroll: !0 }), kn.getOrCreateInstance(i).show()) } _getChildren() { return Q.find(xn, this._parent) } _getActiveElem() { return this._getChildren().find((t => this._elemIsActive(t))) || null } _setInitialAttributes(t, e) { this._setAttributeIfNotExists(t, "role", "tablist"); for (const t of e) this._setInitialAttributesOnChild(t) } _setInitialAttributesOnChild(t) { t = this._getInnerElement(t); const e = this._elemIsActive(t), i = this._getOuterElement(t); t.setAttribute("aria-selected", e), i !== t && this._setAttributeIfNotExists(i, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t) } _setInitialAttributesOnTargetPanel(t) { const e = n(t); e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `#${t.id}`)) } _toggleDropDown(t, e) { const i = this._getOuterElement(t); if (!i.classList.contains("dropdown")) return; const n = (t, n) => { const s = Q.findOne(t, i); s && s.classList.toggle(n, e) }; n(".dropdown-toggle", En), n(".dropdown-menu", Cn), i.setAttribute("aria-expanded", e) } _setAttributeIfNotExists(t, e, i) { t.hasAttribute(e) || t.setAttribute(e, i) } _elemIsActive(t) { return t.classList.contains(En) } _getInnerElement(t) { return t.matches(xn) ? t : Q.findOne(xn, t) } _getOuterElement(t) { return t.closest(".nav-item, .list-group-item") || t } static jQueryInterface(t) { return this.each((function () { const e = kn.getOrCreateInstance(this); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } P.on(document, "click.bs.tab", On, (function (t) { ["A", "AREA"].includes(this.tagName) && t.preventDefault(), l(this) || kn.getOrCreateInstance(this).show() })), P.on(window, "load.bs.tab", (() => { for (const t of Q.find('.active[data-bs-toggle="tab"], .active[data-bs-toggle="pill"], .active[data-bs-toggle="list"]')) kn.getOrCreateInstance(t) })), g(kn); const Ln = "hide", Dn = "show", Sn = "showing", In = { animation: "boolean", autohide: "boolean", delay: "number" }, Nn = { animation: !0, autohide: !0, delay: 5e3 }; class Pn extends z { constructor(t, e) { super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get Default() { return Nn } static get DefaultType() { return In } static get NAME() { return "toast" } show() { P.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(Ln), d(this._element), this._element.classList.add(Dn, Sn), this._queueCallback((() => { this._element.classList.remove(Sn), P.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide() }), this._element, this._config.animation)) } hide() { this.isShown() && (P.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.add(Sn), this._queueCallback((() => { this._element.classList.add(Ln), this._element.classList.remove(Sn, Dn), P.trigger(this._element, "hidden.bs.toast") }), this._element, this._config.animation))) } dispose() { this._clearTimeout(), this.isShown() && this._element.classList.remove(Dn), super.dispose() } isShown() { return this._element.classList.contains(Dn) } _maybeScheduleHide() { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout((() => { this.hide() }), this._config.delay))) } _onInteraction(t, e) { switch (t.type) { case "mouseover": case "mouseout": this._hasMouseInteraction = e; break; case "focusin": case "focusout": this._hasKeyboardInteraction = e }if (e) return void this._clearTimeout(); const i = t.relatedTarget; this._element === i || this._element.contains(i) || this._maybeScheduleHide() } _setListeners() { P.on(this._element, "mouseover.bs.toast", (t => this._onInteraction(t, !0))), P.on(this._element, "mouseout.bs.toast", (t => this._onInteraction(t, !1))), P.on(this._element, "focusin.bs.toast", (t => this._onInteraction(t, !0))), P.on(this._element, "focusout.bs.toast", (t => this._onInteraction(t, !1))) } _clearTimeout() { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface(t) { return this.each((function () { const e = Pn.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](this) } })) } } return q(Pn), g(Pn), { Alert: R, Button: K, Carousel: at, Collapse: pt, Dropdown: hi, Modal: Ni, Offcanvas: zi, Popover: un, ScrollSpy: bn, Tab: kn, Toast: Pn, Tooltip: cn } }));
//# sourceMappingURL=bootstrap.bundle.min.js.map